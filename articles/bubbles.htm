<html><head><title>Пузыри и сотовая связь - Статьи о Паскале - Pascal.Sources.Ru</title>
<meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
<meta name="description" content='Этюды о бесполезной красоте. Этюд 3 - Пузыри и сотовая связь. TMT Pascal.'>
<meta name="keywords" content="tmt, pascal, sources, source code, article, graphics, графика, bubbles, паскаль, пузыри">
<LINK REL=STYLESHEET TYPE="text/css" HREF="../sources.css"></head><BODY><center>

<!--#include virtual="/t_hmenu.htm"-->

<div align='left'>&nbsp;&nbsp;&nbsp;<a class='title' href="index.htm">Статьи о Паскале</a>&nbsp&nbsp;&nbsp;&nbsp;<small>&gt;&gt;</small>&nbsp;&nbsp;&nbsp;&nbsp;Пузыри и сотовая связь
<br>&nbsp;&nbsp;&nbsp;<img border=0 height=4 width=50% align='top' src="../img/b.gif" alt="">
<br>&nbsp;
</div>


<TABLE cellSpacing=0 cellpadding=0 width=97% border=0>

<TR class=subheader><TD colSpan=3><IMG height=2 src="../img/1x1.gif" width=1></td></tr>
<TR><TD class=subheader width=70% nowrap>&nbsp;Этюды о бесполезной красоте - Пузыри и сотовая связь</TD>
<TD nowrap class=black>&nbsp;<img border=0 align=bottom src="../img/mail.gif">&nbsp;
<A href="mailto:evgenij@aport.ru">Евгений Скляревский</A>
</TD>
<TD class=black align='right'>25.09.2001</TD></TR>
<TR vALign=top><TD class=black><p style="margin-left:20px">
<br>Этюды о бесполезной красоте.
Этюд 3 - Пузыри и сотовая связь.
<br>С помощью математики можно описать самые восхитительные
и самые изысканные явления природы. Попытаемся описать и нарисовать
пузыри и пену (хотя некоторые заявляют, что это &quot;попки&quot; ;)
</TD><TD class=black colspan=2 align='right'><img border=0 align=middle src="../img/more.gif">
<br>44k&nbsp;</TD></TR><TR><TD>&nbsp;</TD></TR>

<TR class=subheader><TD colSpan=3><IMG height=2 src="../img/1x1.gif" width=1></td></tr>
<TR><TD colspan=3>
<div style="margin-left:50px">
<p>
<div align=right><small>
Автор: &nbsp;&nbsp;<B><A href="mailto:evgenij@aport.ru">Евгений 
Скляревский</A></B>
<br>
Адаптация для TMT Pascal: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<B><A href="mailto:rswag at sources.ru">Валерий
Вотинцев</A></B>
</small>
<br>
<br>
Оригинал статьи для Visual Basic: <a target=_blank href="http://www.hardnsoft.ru/magazine.php?issue=87&article=182&page=4">Журнал Hard'n'Soft</a>
</div>

<h1>Этюды  о бесполезной красоте</h1>

<h2>Этюд третий. Пузыри и сотовая связь</h2>

<p align="right">
<small>
<I><B>
Мыльный пузырь, пожалуй, самое восхитительное
и самое изысканное явление природы.
</B>
<BR>Марк Твен.</I>
</small>
</p>

<p>
<DIV align="justify">
<p>
<BR><BR>
Из многих замечательных и до 
конца не изученных свойств воды самым потрясающим является, конечно 
же, эффект поверхностного натяжения. Благодаря ему струйка из крана 
становится тоньше и разрывается, роса на траве выпадает в виде 
капелек, а пылинки держатся на поверхности лужи. Пена и пузыри - 
фантастические объекты, они привлекательны не только с эстетической 
точки зрения, но и тем, что тянут за собой шлейф занимательных 
задач.
<p>
Часто бывает, увидишь картинку, придумаешь алгоритм, 
а идея не отпускает. Так вот и с пузырями. Суть в том, что на 
плоскости случайным образом задаются точки, и из них, как из 
центров, строятся окружности с увеличивающимися радиусами и 
уменьшающейся яркостью. В каждой точке плоскости цвет берется от 
окружности с большей яркостью, т.е. от ближайшей. На картинке 
получается нечто похожее на взбитую пену.
<p>
<CENTER>
<IMG src="bubbles1.jpg">
</CENTER>
<p>
Программа 
рисования пузырей несложная. Задается их количество, случайным 
образом выбираются координаты, потом в цикле проходятся все точки 
плоскости с определением расстояния до ближайшего центра, и 
соответственно этому расстоянию уменьшается яркость. Небольшое 
замечание: предварительно экран стоит перевести в режим 16- или 24-битного 
представления цвета.
<p>
Увеличив 
количество пузырей до 100 или 200, получим пену, похожую на легкие 
или какие-то другие объекты явно биологического происхождения. 
<BR><BR>Продолжая увеличивать количество пузырей, мы заставим их 
тесниться и уплотняться, в связи с чем возникают интересные вопросы. 
Сколько соседей в среднем у каждого пузыря и как эта величина 
зависит от плотности размещения? Влияют ли скорость уменьшения 
яркости и рост радиуса на вид пены (на количество соседних пузырей)? 
Нет ли здесь каких-нибудь фрактальных закономерностей, связанных с 
размерностью объектов, и если да, то как определить фрактальную 
размерность пузырей? Или еще - интересно, мыльная пена такая же, как 
пивная, или ее параметры зависят от коэффициента поверхностного 
натяжения?
<p>
А при чем здесь, спросите вы, сотовая связь? 
Очень просто. Мобильный телефон с помощью компьютера выбирает 
антенну, от которой идет самый сильный сигнал, обычно она 
оказывается ближайшей. При перемещении телефона его сопровождение 
передается от одной антенны к другой, с самым сильным сигналом для 
данной точки. Лучшей иллюстрации этого процесса, чем наша картинка с 
пузырями, не найти.
<p>
Но приступим к делу. Приведенная ниже 
программа создана в TMT Pascal 4, хотя вы можете реализовать этот 
нехитрый алгоритм на любом доступном языке. Я, например, свои первые 
пузыри рисовал на Visual FoxPro 6.0 и Visual Basic 6. Скопируйте
приведенный ниже текст в окно редактора TMT Pascal и запустите программу.
<p>
<pre>
<B><font color="#0000FF">Program</font></B> Bubbles;
<I><font color="#008000">(***********************************************)</font></I>
<I><font color="#008000">(* Пузыри                                      *)</font></I>
<I><font color="#008000">(* Автор алгоритма: Евгений Скляревский (VB)   *)</font></I>
<I><font color="#008000">(* ------------------------------------------- *)</font></I>
<I><font color="#008000">(* Адаптация для TMT Pascal:                   *)</font></I>
<I><font color="#008000">(*                  Валерий Вотинцев           *)</font></I>
<I><font color="#008000">(*   MS-DOS 32-bit protected mode              *)</font></I>
<I><font color="#008000">(***********************************************)</font></I>
<B><font color="#0000FF">uses</font></B> CRT, Math, Graph;
<B><font color="#0000FF">Type</font></B>
  dArray = <B><font color="#0000FF">Array</font></B>[0..0] <B><font color="#0000FF">of</font></B> LongInt;
  pArray = ^dArray;
<B><font color="#0000FF">var</font></B>
  i, j, k,
  x, y, q, step,
  xmax, ymax,
  v, col, uu: longint;
  ColDepth: word;
  red, green, blue: LongInt;
  xc, yc, r: pArray;
<B><font color="#0000FF">begin</font></B>
  xmax     := 800; <I><font color="#008000">// Разрешение по горизонтали</font></I>
  ymax     := 600; <I><font color="#008000">// Разрешение по вертикали</font></I>
  ColDepth := 16;  <I><font color="#008000">// Максимальная глубина цвета (бит на пиксел)</font></I>
  v        := 8;   <I><font color="#008000">// Количество пузырей</font></I>
  step     := 4;   <I><font color="#008000">// Шаг движения по x и y (&quot;мозаичность&quot; картины):</font></I>
                   <I><font color="#008000">// step = 1 -&gt;   Рисование по 1 пикселу</font></I>
                   <I><font color="#008000">// step &gt; 1 -&gt;   Рисование квадратами step*step</font></I>
  Randomize;
  <I><font color="#008000">// Установим графический режим</font></I>
  SetSVGAMode(xmax,ymax,ColDepth,LFBorBanked);
  <B><font color="#0000FF">if</font></B> GraphResult&lt;&gt;grOk <B><font color="#0000FF">then</font></B> <B><font color="#0000FF">begin</font></B>             <I><font color="#008000">// Проверка результата</font></I>
    Writeln(</font><font color="#FF0000">'Mode not supported..'</font>);
    Halt(0);
  <B><font color="#0000FF">end</font></B>;
  <I><font color="#008000">// Выделяем память для трех массивов</font></I>
  GetMem(xc,v*SizeOf(LongInt));
  GetMem(yc,v*SizeOf(LongInt));
  GetMem(r, v*SizeOf(LongInt));
  <I><font color="#008000">// Задаем случайные координаты пузырькам</font></I>
  <B><font color="#0000FF">For</font></B> i := 0 <B><font color="#0000FF">To</font></B> pred(v) <B><font color="#0000FF">do</font></B> <B><font color="#0000FF">begin</font></B>
    xc^[i] := Random(xmax);
    yc^[i] := Random(ymax);
  <B><font color="#0000FF">end</font></B>;
  <I><font color="#008000">// В цикле проходим все поле по X и Y</font></I>
  x := 0;
  <B><font color="#0000FF">While</font></B> (x &lt; xmax) <B><font color="#0000FF">do</font></B> <B><font color="#0000FF">begin</font></B>
    y := 0;
    <B><font color="#0000FF">While</font></B> (y &lt; ymax) <B><font color="#0000FF">do</font></B> <B><font color="#0000FF">begin</font></B>
      <B><font color="#0000FF">For</font></B> q := 0 <B><font color="#0000FF">To</font></B> pred(v) <B><font color="#0000FF">do</font></B> <B><font color="#0000FF">begin</font></B>
<I><font color="#008000">{1}</font></I>     r^[q] := Trunc(Power(IntPower((xc^[q] - x),2) +</font>
                                 IntPower((yc^[q] - y),2),0.5));
<I><font color="#008000">{1a}</font></I>    <I><font color="#008000">{r^[q] := Trunc(Power(IntPower((xc^[q] - x),2) +</font></I>
                                 <I><font color="#008000">IntPower((yc^[q] - y),2),0.8));}</font></I>
<I><font color="#008000">{1b}</font></I>    <I><font color="#008000">{r^[q] := Trunc(Power(Abs(IntPower((xc^[q] - x),2) -</font></I>
                                 <I><font color="#008000">IntPower((yc^[q] - y),2)),0.5));}</font></I>
      <B><font color="#0000FF">end</font></B>;
      <I><font color="#008000">// Сортируем пузырьки методом пузырька по возрастанию радиуса</font></I>
      <B><font color="#0000FF">For</font></B> k := 0 <B><font color="#0000FF">To</font></B> v - 2 <B><font color="#0000FF">do</font></B> <B><font color="#0000FF">begin</font></B>
        <B><font color="#0000FF">For</font></B> j := 0 <B><font color="#0000FF">To</font></B> v - 2 <B><font color="#0000FF">do</font></B> <B><font color="#0000FF">begin</font></B>
          <B><font color="#0000FF">If</font></B> r^[j] &gt; r^[j + 1] <B><font color="#0000FF">Then</font></B> <B><font color="#0000FF">begin</font></B>
            uu := r^[j];
            r^[j] := r^[j + 1];
            r^[j + 1] := uu;
          <B><font color="#0000FF">End</font></B>;
        <B><font color="#0000FF">end</font></B>;
      <B><font color="#0000FF">end</font></B>;
      <I><font color="#008000">// Задаем цвет</font></I>
<I><font color="#008000">{2}</font></I>   red   := 255 - r^[0];
      green := 255 - Trunc(r^[0] * 1.3);
      blue  := 255 - Trunc(r^[0] * 1.1);
<I><font color="#008000">{2a}</font></I>  <I><font color="#008000">{red   := 100 - r^[0];</font></I>
      <I><font color="#008000">green := 100 - Trunc(r^[0] * 1.3);</font></I>
      <I><font color="#008000">blue  := 100 - Trunc(r^[0] * 1.1);}</font></I>
<I><font color="#008000">{2b}</font></I>  <I><font color="#008000">{red   := 255 - Trunc(r^[0] * 2.5);</font></I>
      <I><font color="#008000">green := 255 - Trunc(r^[0] * 1.1);</font></I>
      <I><font color="#008000">blue  := 255 - Trunc(r^[0] * 1.1);}</font></I>
      <B><font color="#0000FF">If</font></B> red   &lt; 0 <B><font color="#0000FF">Then</font></B> red   := 0;
      <B><font color="#0000FF">If</font></B> green &lt; 0 <B><font color="#0000FF">Then</font></B> green := 0;
      <B><font color="#0000FF">If</font></B> blue  &lt; 0 <B><font color="#0000FF">Then</font></B> blue  := 0;
      Col := RGBColor(red, green, blue);
      <I><font color="#008000">// Рисуем очередную точку или квадрат</font></I>
      <B><font color="#0000FF">If</font></B> (step = 1) <B><font color="#0000FF">Then</font></B> PutPixel(x, y, Col)</font>
      <B><font color="#0000FF">else</font></B> <B><font color="#0000FF">begin</font></B>
        SetFillColor(Col);
        Bar (x, y, x + step, y + step);
      <B><font color="#0000FF">end</font></B>;
      Inc(y,step);
    <B><font color="#0000FF">end</font></B>;
    Inc(x,step);
  <B><font color="#0000FF">end</font></B>;
  <I><font color="#008000">// Освобождаем выделенную память</font></I>
  FreeMem(xc,v*SizeOf(LongInt));
  FreeMem(yc,v*SizeOf(LongInt));
  FreeMem(r, v*SizeOf(LongInt));
  <I><font color="#008000">// Ждем нажатия Esc</font></I>
  <B><font color="#0000FF">Repeat</font></B> <B><font color="#0000FF">until</font></B> ReadKey=</font><font color="#FF0000">#27</font>;
  CloseGraph;
<B><font color="#0000FF">end</font></B>.
</pre>
<p>
Количество пузырей, точнее, размерность массивов, в которых 
расположены координаты центров и радиуса, задается переменной <b>v</b>. 
Причем память под массивы выделяется динамически, в зависимости
от заданного значения <b>v</b>.
Цикл с переменной <b>i</b> задает центры пузырей 
случайным образом. Для того, чтобы при каждом запуске расположение
пузырей было разным, мы используем функцию <b>Random</b>.
В цикле с переменной <b>q</b> по теореме 
Пифагора вычисляем для каждой точки с координатами <b>x</b>
и <b>y</b> расстояние 
до каждого из центров пузырей <nobr><b>r^[q]</b></nobr>, чтобы выбрать наименьший из них. 
Выбор происходит в циклах с переменными <b>k</b> и <b>j</b>.
Разберетесь, как они 
работают - получите удовольствие от приобщения к классике 
программирования: сортировке элементов массива методом пузырьков. 
(Это не каламбур, название метода не имеет отношения к теме статьи, 
просто с каждым проходом цикла меньшие числа <всплывают вверх>. 
Вообще, переменная <b>uu</b> и присвоение ей значения <nobr><b>r^[j+1]</b></nobr>
нужны только в 
случае сохранения всего массива для дальнейшей работы, нас же 
интересует только наименьшее значение <nobr><b>r^[0]</b></nobr>, поэтому цикл можно 
сократить на две строки, имеющие, скорее, методический смысл.) 
<p>
Получив минимальный радиус для текущей точки, можно 
приступать к формированию цвета - это и есть изюминка всей затеи. 
Каждая составляющая rgb-функции цвета уменьшается пропорционально 
радиусу. Меняя коэффициенты и максимальное значение, равное в 
примере 255, на меньшее, можно получать различные оттенки пены и 
регулировать контрастность рисунка.
Попробуйте убрать комментарии с блоков, помеченных как {2a}
и {2b}.
<p>
<CENTER>
<IMG src="bubbles2.jpg">
</CENTER>
<p>
Программа предоставляет 
безграничный простор для экспериментов. Попробуйте сделать так, 
чтобы яркость не уменьшалась с удалением от центра пузыря, а 
увеличивалась, и вы будете поражены получившейся картиной. 
Попробуйте при вычислении радиуса поменять показатель степени с 0,5 
на 0,8 или 0,3 (кстати, именно для этого мы и воспользовались функцией Power,
а не Sqrt). Уберите комментарии со строки {1a}.
<p>
Попробуйте также вместо формулы <nobr><b>r<sup>2</sup>=x<sup>2</sup>+y<sup>2</sup></b></nobr>
применить <nobr><b>r<sup>2</sup>=x<sup>2</sup>-y<sup>2</sup></b></nobr>, чтобы 
получить нечто гиперболическое. Для этого раскройте комментарий вокруг
строки {1b}.
<p>
А бесконечные игры с цветами, шагом 
и количеством пузырей... Естественно, что с уменьшением шага 
рисования (переменная <b>step</b>) и увеличением количества пузырей (<b>v</b>)
время рисования 
возрастает, т.к. в каждой точке рисунка проверяются расстояния до 
всех центров пузырей, а любые попытки оптимизировать алгоритм лишь 
замедлят работу программы.
<p>
А что если разукрасить пузыри - каждый в 
свой цвет? Тут придется поработать, ведь нужно не только задать 
массив цветов для каждого пузыря и заполнить его случайным образом, 
но и, отслеживая соответствие каждой точки плоскости ближайшему 
центру, запоминать еще его цвет. Это непросто, потому что при выборе 
наименьшего радиуса его индекс в массиве теряется. Задача, конечно, 
решаемая, и если вы с ней справитесь, то будете сторицей 
вознаграждены получившейся картиной. Экран заполняется разноцветными 
шариками, как в моделях сложных молекул, или одинокими фонариками - 
в зависимости от ваших настроек.
<p>
<CENTER>
<IMG src="bubbles3.jpg">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<IMG src="bubbles4.jpg">
</CENTER>
<p>
Вот и все. Как ни странно, 
нам удалось связать вместе пену, TMT Pascal и мобильники. Отладка 
программы и попутные опыты доставят вам массу удовольствия. Задание 
на дом: научите пену бурлить, чтобы некоторые пузыри лопались, а 
соседи занимали их место. Да, и не забудьте выложить изображения на 
свой сайт: Созерцание пузырей рождает прекрасные мысли, недоступные 
в обыденной суете. Может, в этом и состоит их предназначение? 
Поразмышляйте об этом на досуге.



</DIV>
<p>

<!--#include virtual="/t_footer.htm"-->
