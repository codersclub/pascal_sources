<html><head><title>Алгоритм преобразует алгоритм! - Статьи о Паскале - Pascal.Sources.Ru</title>
<meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
<meta name="description" content='Об особенностях теории "конечных автоматов" и ее реализации на Паскаль и Дельфи.'>
<meta name="keywords" content="pascal, sources, source code, article, теория, конечных, автоматов ">
<LINK REL=STYLESHEET TYPE="text/css" HREF="../sources.css"></head><BODY><center>

<!--#include virtual="/t_hmenu.htm"-->

<div align='left'>&nbsp;&nbsp;&nbsp;<a class='title' href="index.htm">Статьи о Паскале</a>&nbsp&nbsp;&nbsp;&nbsp;<small>&gt;&gt;</small>&nbsp;&nbsp;&nbsp;&nbsp;Алгоритм преобразует алгоритм!
<br>&nbsp;&nbsp;&nbsp;<img border=0 height=4 width=60% align='top' src="../img/b.gif" alt="">
<br>&nbsp;
</div>

<TABLE cellSpacing=0 cellpadding=0 width=97% border=0>

<TR class=subheader><TD colSpan=3><IMG height=2 src="../img/1x1.gif" width=1></td></tr>
<TR><TD class=subheader width=70% nowrap>&nbsp;Алгоритм преобразует алгоритм!</TD>
<TD nowrap class=black>&nbsp;<img border=0 align=bottom src="../img/mail.gif">&nbsp;
<A href="mailto:Daisy25@mail.ru">George Columbow</A>
</TD>
<TD class=black align='right'>06.08.2001</TD></TR>
<TR vALign=top><TD class=black><p style="margin-left:20px">
<br>Об особенностях теории "конечных автоматов" и ее реализации на Паскаль и Дельфи. 
</TD><TD class=black colspan=2 align='right'><img border=0 align=middle src="../img/more.gif">
<br>31k&nbsp;</TD></TR><TR><TD>&nbsp;</TD></TR>

<TR class=subheader><TD colSpan=3><IMG height=2 src="../img/1x1.gif" width=1></td></tr>
<TR><TD colspan=3>
<div style="margin-left:50px">

<H1 align=center>Алгоритм преобразует алгоритм!</H1>

<P align=center><A href="mailto:Daisy25@mail.ru">George Columbow</A> 
<p align=right>Опубликовано в <a href="http://www.citforum.ru/programming/digest/formal.shtml">CitForum</a>
&nbsp;&nbsp;</p>
<P>При программировании на Delphi или Паскале иногда попадаются задачи, 
которые трудно "втиснуть" в стандартные конструкции языка. А решение лежит 
совсем рядом - в теории конечных автоматов. Мы не будем залезать в дебри, 
а просто покажем как это делается.
<P>
<UL>
  <LI>Перед началом 
  <LI><A href="#LIRIC">Лирическое отступление</A>
  <LI><A href="#WHY">Зачем это надо</A> 
  <LI><A href="#THEORY">Немного теории</A> 
  <LI><A href="#HOW">И как же это делается ?</A> 
  <LI><A href="#SO">Осознание: некоторые следствия и последствия</A> 
  <LI><A href="#SORRY">"Отмазка"</A> 
  </LI></UL>

<p style="padding-left:150px;">
      Автор заранее просит у читателя прощения за то, что в тексте 
      статьи используются блок-схемы. Это не модно <B>сейчас</B>, однако 
      есть случаи, когда все-таки стоит их использовать.
      <br>
      <br>
      Рассуждения об алгоритмах - как раз такой <I>особый</I> случай. 
</P>

<HR>
<A name=LIRIC></A>
<H4 align=center>Лирическое отступление</H4>

<P>Однажды, еще в школе, на уроке алгебры, я в первый раз услышал о 
существовании формальных преобразований. Помнится это были (a+b) 
<SUP><SMALL><B>2</B></SMALL></SUP>.
<P>Это было нечто! Меня поразила сама возможность выполнять ряд простых 
шагов и гарантированно получать <B>правильный</B> результат.
<P>Ну а уж потом были примеры из тригонометрии: четырехэтажные дроби с 
ужасным количеством синусов, косинусов и бесконечно длинными аргументами, 
которые путем небольшой игры ума сворачивались в робкое 1+sin(x), а то и 
просто в неприметную 1.
<P>С тех самых пор я весьма неравнодушен к формальным преобразованиям и 
стараюсь найти им применение в программировании. И, вы знаете, иногда 
получается! :-)
<P>
<HR>
Давным-давно, когда люди еще не придумали объектно-ориентированное 
программирование, модным направлением было программирование 
<B>структурное</B>. Шутки шутками, но в результате именно структурного 
подхода мы сейчас имеем Pascal и <BIG><B>Delphi</B></BIG>.
<P><SMALL>Почему я говорю то Паскаль, то Дельфи? Просто потому, что 
лингвистическая основа Delphi - это Object Pascal, сильно выросший из 
детских штанишек, но все же узнаваемый. И новые объектно-ориентированные 
возможности и замечательные библиотеки классов в совокупности с 
CASE-средствами так и не скрыли полностью длинные уши структурного языка 
(и это замечательно!). Они вылезают то здесь, то там, в отдельных 
процедурах, в обработчиках событий... :-)
<P></SMALL>Так вот, в те давние времена возникла следующая ситуация:
<P><A name=WHY></A>
<UL>
  <LI>"Сочинение" алгоритмов решения различных задач - процесс творческий, 
  а творчество очень не любит каких-либо ограничений. Cтало быть алгоритм 
  может быть любым, сколь угодно запутанным, образующим петли и прочие 
  нелинейности.<BR>(Особенно этим грешат процедуры, занимающиеся разного 
  рода синтаксическим разбором.)
  <P></P>
  <LI>Стандартный Паскаль имеет очень ограниченное количество структурных 
  инструкций ( if-then-else, while-do и т.д., вы это лучше меня знаете...)
  <P></P>
  <LI>А программу-то написать хочется! Что делать ?
  <P></P>
  <LI>А нельзя ли как-нибудь "втиснуть" этот наш премудрый алгоритм в 
  куцый набор инструкций? 
  <LI>Можно! Причем используя вполне <A 
  href="#FORMAL">формальное 
  преобразование</A>.
  <P></P>
  <LI>Вот этим мы сейчас и займемся. </LI></UL>
<HR>
Но в начале - немного теории.
<P><A name=THEORY></A>
<TABLE border=0 cellPadding=5 cellSpacing=0 width="95%">
  <TR>
    <TD colSpan=5>Итак, структурное программирование учит нас, что есть 
      5 основных конструкций, из которых как из кубиков строится любая 
      процедура: </TD></TR>
  <TR>
    <TD><IMG alt="" border=0 height=100 
      src="formal_seq.gif" 
      width=80></TD>
    <TD><IMG alt="" border=0 height=100 
      src="formal_if.gif" 
      width=80></TD>
    <TD><IMG alt="" border=0 height=100 
      src="formal_while.gif" 
      width=80></TD>
    <TD><IMG alt="" border=0 height=100 
      src="formal_repeat.gif" 
      width=80></TD>
    <TD><IMG alt="" border=0 height=100 
      src="formal_case.gif" 
      width=180></TD></TR>
  <TR align=middle>
    <TD>SEQUENCE</TD>
    <TD>IF-THEN-ELSE</TD>
    <TD>WHILE-DO</TD>
    <TD>REPEAT-UNTIL</TD>
    <TD>CASE</TD></TR>
  <TR>
    <TD colSpan=5><SMALL>
      <CENTER>Историческая справка для любознательных. </CENTER><BR>По 
      этому поводу тоже было немало дебатов: сколько же структур 
      действительно основных, а какие следует считать производными. Левые 
      радикалы даже дошли до того, что основных структур только две: 
      SEQUENCE и WHILE, а все остальные можно построить из них. Самое 
      смешное, что это действительно так. Правда, размер текста программы 
      при этом распухает неимоверно, но это уже детали... :-) 
  </SMALL></TD></TR></TABLE>
<P>
В нашем запутанном алгоритме наверняка не все так ужасно, как кажется. 
Скорее всего, там можно найти несколько фрагментов, подходящих под 
определение чисто структурных конструкций. Вопрос лишь в том, как эти 
конструкции соединить между собой. 
<P>А вот в этом как раз может помочь наша рабочая лошадка - непотопляемая 
конструкция REPEAT-CASE. При умелом применении эта нехитрая пара команд 
может "переварить" алгоритм любой сложности и запутанности. Главное, чтобы 
ВЫ четко представляли что делаете. 
<HR>
<A name=HOW></A>Однако хватит нам ходить вокруг да около, не пора ли 
заняться делом? 
<TABLE border=0 cellPadding=5 cellSpacing=0 width="95%">
  <TR>
    <TD>Предположим, у нас есть алгоритм следующего вида:<BR><IMG alt="" 
      border=0 height=150 
      src="formal_block1.gif" 
      width=220> </TD>
    <TD width="60%">Хитрый ли он? <BR>Да нет, конечно! Если 
      приглядеться, он легко разбивается на 3 вложенные стандартные 
      структуры:<BR><IMG alt="" border=0 height=150 
      src="formal_block1a.gif" 
      width=215> </TD></TR>
  <TR>
    <TD colSpan=2>Так что мы с легкой душой можем воплотить его в 
            программе вроде такой: <PRE><BIG><B>
  repeat
    while C1 do B1;
    if C2 then B2
      else B3;
  until C3;

</B></BIG></PRE>И все! Очень красиво и компактно, спасибо большое 
      дедушке Вирту.
      <P>Как было бы хорошо, если бы в жизни нам попадались только такие 
      алгоритмы. Однако в таком случае, вам незачем было бы читать эту 
      статью! :-) </P></TD></TR></TABLE>
<TABLE border=0 cellPadding=5 cellSpacing=0 width="95%">
  <TR>
    <TD vAlign=top width=200><B>А что вы скажете на это:</B><BR><IMG 
      alt="" border=0 height=150 
      src="formal_block2.gif" 
      width=142> </TD>
    <TD>Выглядит вроде просто, это мы мигом!
      <P>Гмм.. да.. пробуем и так и эдак - в стандартный Паскаль это явно 
      не укладывается. Можно, конечно, попытаться "расшить" процедурные 
      блоки B1 и B3 или применить GOTO или EXIT из цикла. Но все это, 
      согласитесь, выглядит как-то жалко и самодеятельно. Опять же надо 
      каждый раз думать где разомкнуть цикл... 
      <P>И вот тут-то появляемся мы, (на белом коне !-) с нашей 
      универсальной отмычкой по имени REPEAT-CASE.
      <P></P></TD></TR></TABLE><A name=FORMAL></A>Теперь мы можем 
выполнить несколько чисто формальных шагов: 
<UL>
  <LI>Выделяем в нашем алгоритме фрагменты, которые хорошо укладываются в 
  структурную модель (если такие есть). В нашем случае такой фрагмент 
  только один: B2 + C2, т.е. последовательность из блока и условия. 
  <BR><SMALL>( Если вы считаете, что фрагмент можно взять несколько шире и 
  включить в него C1+B2+C2, я с вами соглашусь, но см.<A 
  href="#TWO">ниже</A>)</SMALL>
  <P></P>
  <LI>Вне этих фрагментов ставим <B>жирные точки</B> в следующих местах: 
  <UL>
    <LI>на входе в модуль (обозначим ее <B>1</B>) 
    <LI>на выходе модуля (обозначим <B>0</B>) 
    <LI>на входах и выходах всех фрагментов, что мы нашли 
    <LI>во всех местах, где есть пересечение линий на блок-схеме 
  </LI></UL>Скорее всего, многие точки просто сольются - пусть, мы будем 
  считать их за одну. Например, у нас точка <B>1</B> на входе модуля 
  совпадает с точкой пересечения линий входящей и от B3. <IMG align=right 
  alt="" border=0 height=150 
  src="formal_block2a.gif" 
  width=142> 
  <LI>Пронумеруем оставшиеся точки произвольно. <A 
  href="#SO">Позже</A> 
  мы еще поговорим о том, что могут <I>на самом деле</I> означать эти 
  номера. В нашем примере получается 4 точки от <B>0</B> до <B>3</B>. 
  <LI>Теперь мы готовы перейти к модели конечного автомата и написать-таки 
  нашу программу. 
  <LI>Представьте, что есть некий блок, который может находиться в одном 
  из 4 состояний. И есть набор действий, в результате которых блок 
  переходит из одного состояния в другое. 
  <LI>Для отображения этого самого состояния, заведем в программе 
  некоторую переменную, скажем, State. А внутри веток CASE будем изменять 
  ее состояние. 
  <LI>Пишем нашу программу: <PRE><BIG><B>var State:integer;
begin
  State:=1;  {для любого алгоритма}
  repeat
    case State of
...
    end;
  until State=0; {тоже для любого алгоритма}
end;
</B></BIG></PRE>
<LI>Теперь пропишем ветки CASE. Не забудьте в конце каждой ветки 
уточнить состояние: <PRE><BIG><B>    case State of
1: begin B1; if C1 then State:=2 else State:=3 end;
2: begin B2; if C2 then State:=0 else State:=3 end;
3: begin B3; State:=1 end;
    end;
</B></BIG></PRE>
  <LI>Все! Программа готова. Идите и попробуйте, она работает. И с точки 
  зрения логики Паскаля все безупречно - никаких тебе GOTO и прочих 
  неприятностей. </LI></UL><A name=SO></A>

<CENTER>
<H4>Осознание</H4>
</CENTER>

А теперь, после того, как мы добились столь 
блестящего результата, давайте осознаем: что же мы сделали и что у нас 
получилось.
<P>
<CENTER><B>Что сделали</B> (или как все это назвать 
по-настоящему)</CENTER>
<UL>
  <LI>Мы изобразили наш алгоритм как блок-схему или, другими словами, 
  направленный граф 
  <LI>Затем провели инвариантное преобразование этого графа с выделением 
  нескольких стационарных состояний программы - конечного автомата 
  <LI>В результате получили новый граф, который легко укладывается в 
  структурные конструкции Паскаля (Delphi) </LI></UL>
<CENTER><B>Что из это следует</B></CENTER>
<P>Проводя указанные действия несколько раз для разных алгоритмов, можно 
заметить, что <I><B>на самом деле</B></I> наши произвольно расставленные 
точки-состояния не такие уж случайные и произвольные. Как правило, при 
более глубоком рассмотрении вашего конкретного алгоритма можно найти 
каждому из этих состояний свое название. Это название может быть гораздо 
более выразительным, чем просто 1-2-3, поскольку это действительно 
состояния вашей программы.
<P>О чем я говорю? Пусть ваш алгоритм занимается, скажем, синтаксическим 
разбором HTML-файла. Тогда одно из состояний может звучать как "Обнаружен 
тэг BODY" или "Найден конец документа".
<P>Паскаль предлагает нам замечательное средство для работы с такими 
обозначениями в символическом виде и об этом средстве сейчас часто 
забывают. Программа из нашего примера может выглядеть так: <PRE><B>var State:(START, EOF_found, Line_Added, DONE);
begin
  State:=START;  {для любого алгоритма}
  repeat
    case State of
START:      begin B1; if C1 then State:=EOF_Found else State:=Line_Added end;
EOF_Found:  begin B2; if C2 then State:=DONE else State:=Line_Added end;
Line_Added: begin B3; State:=START end;
    end;
  until State=DONE; {тоже для любого алгоритма}
end;
</B></PRE>Замечательно, что Delphi все еще поддерживает эту спецификацию и 
даже показывает при отладке символьное представление состояния! Это очень 
удобно на практике. Спасибо, <A href="http://www.inprise.ru/">Borland</A>! 

<P>
<CENTER><B>Другое следствие</B></CENTER>
<P>Возможно вы, как и я, проделав подряд несколько таких преобразований и 
войдя во вкус, заметите, что стали мыслить при программировании чуть-чуть 
иначе. Иногда, особенно когда задача несколько запутана, хочется сразу 
выделить несколько важных состояний и строить обработчик уже вокруг них. 
Это правильное желание, ему стоит потакать. :-)
<P>Кстати, сейчас тема конечных автоматов вновь стала актуальной и то и 
дело мелькает на страницах компьютерных журналов. 
<P>
<CENTER><B>Небольшое исследование: крайние случаи</B></CENTER>
<P><IMG align=right alt="" border=0 height=150 
src="formal_block2b.gif" 
width=142> Как сказал один мудрый человек, <I>"Идея, доведенная до 
абсурда, часто превращается в свою противоположность"</I>. Давайте 
попробуем довести наш метод до крайней степени.
<P>В нашем случае это означает добавление еще двух состояний - 4 и 5. 
Тогда программа примет вид: <PRE><B>    case State of
1: begin B1; State:=4 end;
2: begin B2; State:=5 end;
3: begin B3; State:=1 end;
4: if C1 then State:=2 else State:=3;
5: if C2 then State:=0 else State:=3;
    end;
</B></PRE>Хорошо это или плохо? 
<P>Хорошо, в том смысле, что даже при таком издевательстве программа не 
перестает работать правильно. С другой стороны, посмотрите на исходный 
код: где прозрачность, где легкость и ясность? Суть алгоритма растворена в 
сплошных переходах состояний и из-за этого теряется.<BR>Нет, пожалуй этот 
вариант нам не подходит.
<P>
<HR>
<A name=TWO></A><IMG align=right alt="" border=0 height=150 
src="formal_block2a.gif" 
width=142> А что, если пойти в другую сторону и уменьшить число выделенных 
состояний? В нашем примере реально только исключить состояние <B>2</B>. 
<SMALL><BR>(Да, я знаю, на блок-схеме двойка есть, но давайте пока ее не 
замечать, OK? :)</SMALL>
<P>После "приведения подобных" программа будет иметь следующий вид: <PRE><B>    case State of
1: begin 
     B1; State:=3;
     if C1 then begin 
       B2; if C2 then State:=0 
     end
   end;
3: begin B3; State:=1 end;
    end;
</B></PRE><SMALL>(Если непонятно, то здесь формально получаются две ветки 
ELSE, ведущие обе к третьему состоянию. Если состояние вынести вверх, до 
условия, то программа получается короче. Впрочем, это - дело вкуса :) 
</SMALL>
<P>Как вам этот вариант? Мне кажется он тоже имеет право на жизнь, хотя 
лично мне вариант с четырьмя состояниями нравится больше. Как-то он 
нагляднее показывает что куда переходит и при каких условиях. А вам? <A 
name=SORRY></A>
<HR>
Предвижу возражения такого толка, что при подобном подходе программы будут 
иметь повышенную склонность к зацикливанию. И да и нет. Циклы вообще 
склонны к зацикливанию :-) особенно если написать что-нибудь вроде 
<B>repeat until false;</B>. Так на то и голова дана, чтобы карась не 
дремал!
<P>А если серьезно, то устойчивость работы преобразованных таким образом 
программ прямо и недвусмысленно показывает, насколько удачно вы 
проработали исходную блок-схему и насколько аккуратно ее преобразовали. 
Поскольку на то оно и <B>инвариантное</B> преобразование, чтобы ничего не 
менять в <B>смысле и логике программы</B>, а затрагивать лишь ее 
<B>внешнее представление</B>.
<P>
<p style="padding-left:150px;">
      <I>Возможно кто-нибудь захочет поручить и само это 
      преобразование программе, это мог бы быть компонент Delphi или 
      отдельная утилита, этакий Diagram Automation Wizard. Если такое 
      случится, мне бы очень хотелось посмотреть на результат.</I>
</P>

<HR width="50%">
И, наконец, мне нужно расставить <BIG><B>точки над i.</B></BIG>
<P>Я ни в коей мере не претендую на авторство в данном формальном подходе, 
более того, все проблемы и решения, изложенные в этой статье, известны уже 
довольно давно. Моя цель была просто напомнить вам об одном красивом, но, 
боюсь, забытом подходе к программированию на Паскале и Delphi. 
<P align=right>Пишите, если надумаете чем поделиться,<BR><A 
href="mailto:Daisy25@mail.ru">George Columbow</A> </P>

<br>
</DIV>


<!--#include virtual="/t_footer.htm"-->
