<html><head><title>Криптозащита текстовых файлов - Статьи о Паскале - Pascal.Sources.Ru</title>
<meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
<meta name="description" content='Криптографические преобразования строк сводятся к перестановкам (перемещениям), заменам (подстановкам) символов в строке или комбинациям обоих методов. Поскольку при перестановках коды символов не меняются, то для шифрования текстовых файлов в большинстве случаев их можно использовать без всяких ограничений. Пример криптозащиты с помощью перестановок показан в листинге 2.'>
<meta name="keywords" content='pascal, sources, source code, article, cryptography, Криптозащита текстовых файлов. Криптографические преобразования строк сводятся к перестановкам (перемещениям), заменам (подстановкам) символов в строке или комбинациям обоих методов. Поскольку при перестановках коды символов не меняются, то для шифрования текстовых файлов в большинстве случаев их можно использовать без всяких ограничений. Пример криптозащиты с помощью перестановок показан в листинге 2.'>
<LINK REL=STYLESHEET TYPE="text/css" HREF="../sources.css"></head><BODY><center>
<!--#include virtual="/t_hmenu.htm"-->
<div align='left'>&nbsp;&nbsp;&nbsp;<a class='title' href="index.htm">Статьи о Паскале</a>&nbsp&nbsp;&nbsp;&nbsp;<small>&gt;&gt;</small>&nbsp;&nbsp;&nbsp;&nbsp;Криптозащита текстовых файлов
<br>&nbsp;&nbsp;&nbsp;<img border=0 height=4 width=60% align='top' src="../img/b.gif" alt="">
<br>&nbsp;
</div>
<TABLE cellSpacing=0 cellpadding=0 width=97% border=0>
<TR class=subheader><TD colSpan=3><IMG height=2 src="../img/1x1.gif" width=1></td></tr>
<TR><TD class=subheader width=70% nowrap>&nbsp;Криптозащита текстовых файлов
</TD><TD nowrap class=black>&nbsp;&nbsp;
Василий Текин
</TD>
<TD class=black align='right'>17.12.2001</TD></TR>
<TR vALign=top><TD class=black><p style="margin-left:20px">
<br>Криптографические преобразования строк сводятся к перестановкам (перемещениям), заменам (подстановкам) символов в строке или комбинациям обоих методов. Поскольку при перестановках коды символов не меняются, то для шифрования текстовых файлов в большинстве случаев их можно использовать без всяких ограничений. Пример криптозащиты с помощью перестановок показан в листинге 2.
</TD><TD class=black colspan=2 align='right'><img border=0 align=middle src="../img/more.gif">
<br>26k&nbsp;</TD></TR><TR><TD>&nbsp;</TD></TR>
<TR class=subheader><TD colSpan=3><IMG height=2 src="../img/1x1.gif" width=1></td></tr>
<TR><TD colspan=3>
<div style="margin-left:50px">

<br>
<b>
<A href="http://www.osp.ru/pcworld/2001/05/">Мир ПК, #05/2001</a>
</b>
<br>
Постоянный адрес статьи: <A href="http://www.osp.ru/pcworld/2001/05/048.htm">http://www.osp.ru/pcworld/2001/05/048.htm</a>
<HR SIZE=1>

<h2>Криптозащита текстовых файлов</h2>
Василий Текин
<BR>
<br>
15.05.2001

<p>
<P>Слово за слово — это для человека, а вот текстовый процессор оперирует только строками, и криптографические преобразования не должны нарушать работу этого механизма.</P>
<P>Текст по-прежнему выступает основным средством передачи информации и представляет собой набор абзацев, состоящих из строк. На работу со строками ориентированы все без исключения текстовые процессоры турбо-сред компиляторов, а также большинство других текстовых процессоров, кроме Microsoft Word. Кстати, удобство применения последнего представляется спорным, ведь никто не ездит по собственной квартире на автомобиле... Однако почему-то используют этот явно избыточный редактор вместо простых средств обработки текстов и, хуже того, требуют того же от других.</P>
<P>Большинство языков программирования предоставляют специалисту готовые средства для работы со строками переменной длины. Традиционно младший байт внутреннего представления такой строки содержит ее текущую длину, далее следуют символы строки от первого до последнего. Максимальная длина строки в таком представлении равна 255 символам. Иногда на описание текущей длины строки отводится два байта (например, в Delphi), тогда максимальная длина строки составляет 65 534 символа. В функциях DOS и программах, написанных на Си и Си++, широко используются также ASCIIZ-строки теоретически неограниченной длины. Однако большинство текстовых редакторов, включая turbo-среды самих этих компиляторов, их не используют, отдавая предпочтение традиционному представлению.</P>
<P>Текстовый файл является последовательностью строк из символов с кодами 20h..FFh длиной от 0 до 255 каждая, разделенную управляющими символами CR/LF=0Dh/0Ah (возврат каретки/перевод строки). Символы с кодами 00h..1Fh, включая CR/LF, считаются управляющими и используются в текстах для специальных целей. Ориентированные на традиционное представление строк языки программирования высокого уровня, такие как Бейсик и Паскаль, содержат автоматические средства ввода-вывода для вставки (при записи) и удаления (при чтении) пар символов CR/LF, разделяющих строки текстового файла. Для файла, подвергнутого криптографическим преобразованиям, затрагивающим также разделители строк CR/LF, применение автоматических средств строкового ввода-вывода становится невозможным.</P>
<P>Автоматические средства разблокирования строк реагируют практически только на символ возврата каретки CR (код 13h) и перестают работать правильно, если этот символ оказывается частью строки. Нарушение работы механизма блокирования/разблокирования связано в данном случае с отличием внешнего (в файле) и внутреннего (в памяти) представления строк текста. В этом смысле гораздо удобнее ASCIIZ-строки, разделителем которых служит символ с кодом 0.</P>
<P>Чтобы использовать традиционные средства ввода-вывода для работы и с зашифрованным текстовым файлом, необходимо сохранить его строковую структуру. Иначе говоря, криптографические преобразования не должны мешать работе механизма блокирования/разблокирования строк. Последнее условие выполняется, если шифрующие механизмы не порождают символов CR, разрезающих строку на части при ее записи на диск или выводе на экран. Конечно, подобное ограничение снижает криптостойкость шифрованных текстов, но другого выбора нет.</P>
<P>Вначале необходимо уяснить роль управляющих символов системы для работы с текстовыми файлами. Начать естественнее с DOS, воспользовавшись, например, программой, приведенной в <A HREF="#lis1">листинге 1</A>.</P>

<P>Работа этой программы показывает, что из управляющих символов, помимо упомянутых CR/LF, специальным образом интерпретируются еще символы звонка BEL (код 07h), &lt;Backspace&gt; BS (код 08h) и горизонтальной табуляции HT (код 09h), а также маркер конца текста ^Z (код 1Ah), действие которого проявляется при выводе на экран с помощью команды TYPE. Остальные управляющие символы в текстовых файлах DOS следует считать обычными, по крайней мере до тех пор, пока эти файлы не выводятся на печать.</P>
<P>Криптографические преобразования строк сводятся к перестановкам (перемещениям), заменам (подстановкам) символов в строке или комбинациям обоих методов. Поскольку при перестановках коды символов не меняются, то для шифрования текстовых файлов в большинстве случаев их можно использовать без всяких ограничений. Пример криптозащиты с помощью перестановок показан в <A HREF="#lis2">листинге 2</A>.</P>

<P>Здесь таблица перестановок CryptTab (играющая роль гаммы шифра) создается случайным образом при каждом вызове программы. Номер элемента I и соответствующее значение CryptTab [I] указывают положение в строке переставляемых элементов. Шифрование и дешифрирование отличаются направлением перебора символов строки. Программа выводит четыре текстовые строки (каждую своим цветом): исходную (желтый), из текстового файла (зеленый), шифровку исходной (циан) и результат ее расшифровки (белый). Обратите внимание на действие преднамеренно введенного управляющего символа перевода строки.</P>
<P>Криптозащиту с помощью замен рассмотрим на примере шифра Гая Юлия Цезаря [1, с. 48], описываемого преобразованиями, соответственно прямым:</P>

<P>X = Y + (N – Shift)       (mod N)</P>
<P>и обратным:</P>

<P>Y = X + Shift,                (mod N)</P>
<P>где X и Y — позиция исходного и кодированного символа в N-символьном алфавите; &lt;Shift&gt; — сдвиг 1,2...N-1, не зависящий от номера позиции символа в строке. И взятие по (mod N) напоминает, что соответствующее значение берется по модулю N числа символов в алфавите. Заметим, что всегда</P>

<P>Y = Y + N.                     (mod N)</P>

<P>К сожалению, напрямую подобное преобразование неприменимо из-за несовпадения способа нумерации строчных символов в алфавите с их кодами в таблице ASCII. Однако преобразованием можно пользоваться, если положение в алфавите символа C с кодом Ord (C) из диапазона 20h..FFh считать равным:</P>

<P>X = Ord (C) – 32.</P>

<P>Число символов в таком алфавите (N) равно 224. Для фиксированного значения сдвига &lt;Shift&gt; программа шифрования/дешифрирования может быть построена, как показано в <A HREF="#lis3">листинге 3</A>.</P>

<P>По сути дела, сдвиг и порождает фиксированную таблицу соответствия между символами исходного и зашифрованного сообщений. Всего таких таблиц, т. е. способов расшифровки, для N-символьного алфавита может быть ровно N. Причем каждая таблица имеет простое устройство, и все они могут быть проверены даже вручную.</P>
<P>Усиление криптостойкости шифра Цезаря достигается в том случае, если считать сдвиги зависящими от положения шифруемого символа в строке. Тогда каждому положению символа соответствует своя шифровальная таблица. Число различных таблиц по-прежнему равно N, однако для расшифровки уже необходимо знать порядок следования таблиц. Последнее и обусловливает повышение надежности шифра. При этом достаточно хранить только таблицу сдвигов, выполняющую функцию гаммы шифра, а сами таблицы преобразований символов реконструировать по мере надобности, используя приведенные выше формулы. Способ реализации такого подхода показан в <A HREF="#lis4">листинге 4</A>.</P>

<P>Для заполнения таблицы сдвигов в этой программе используется встроенный в Turbo Pascal 3.xx высококачественный датчик случайных чисел. Исследования показывают, что начальное состояние такого датчика определяется 4-байтовым числом, что в результате дает всего 4 294 967 296 (232) различных способов шифрования. Однако это число можно увеличить, используя для создания гаммы шифра два или более подобных датчиков и комбинируя порождаемые ими случайные последовательности.</P>
<P>К сожалению, Turbo Pascal 3.xx не предоставляет документированных способов управления встроенным в него датчиком случайных чисел. Можно, конечно, разобраться, как это делается, или просто сочинить собственный датчик (один или несколько), пусть даже и худшего качества. Пример такого датчика, основанного на рекомендациях Д. Кнута [2, с. 261—267], представлен в <A HREF="#lis5">листинге 5</A>.</P>

<P>Для приведения значения Y, вырабатываемого этим генератором, к заданному диапазону 0..N-1 (N&gt;0) можно воспользоваться следующей формулой:</P>
<P>Z := Y                         ( mod N);</P>
<P>if Z &lt; 0 then Z := Z + N.</P>
<P>Вместо приведения примеров применения подобных генераторов рассмотрим прямой способ использования пароля для шифрования по Цезарю. Текст программы приведен в <A HREF="#lis6">листинге 6</A>.</P>

<P>Достаточно длинный и не смысловой пароль способен создать уже значительные трудности при попытке взлома, если только злоумышленник не раздобудет фрагмент исходного текста, по которому легко восстановить весь пароль и расшифровать текст.</P>
<P>В программах, приведенных в листингах 3, 4 и 6, предусматривался обход управляющих символов с кодами 00h..1Fh. Если из обработки надо исключить только некоторые символы, то перед выполнением криптографических преобразований их можно просто переместить в конец алфавита, а затем вернуть на свое место.</P>
<P>Криптографические преобразования, продемонстрированные в <A HREF="#lis7">листинге 7</A>, затрагивают все символы строки за исключением символов перевода строки CR (код 0Dh), возврата каретки CR (код 0Ah), горизонтальной табуляции HT (код 09h), &lt;Backspace&gt; BS (код 08h), звонка BEL (код 07h) и, как наследство проклятого прошлого, ^Z — маркера конца текста (с кодом 1Ah). Эти символы в исходном и кодированном текстах остаются на своих местах. Сам алгоритм шифрования не отличается от использованного в <A HREF="#lis4">листинге 4</A>.</P>

<P>Аналогичным образом решается и задача преобразований только части символов алфавита с сохранением остальных на своих местах.</P>
<P>Мы рассмотрели применение лишь простейшего способа шифрования текстов Гая Юлия Цезаря на основе перестановок и циклических замен. Надежность каждого из подобных шифров невысока. В то же время их последовательное и многократное применение может повысить криптостойкость шифра. Однако использование одних лишь перестановок или только замен не повышает устойчивости шифра ко взлому и даже способно привести к его вырождению [1, с.126]. Комбинация перестановок и подстановок гораздо устойчивее, и применяется в профессиональных системах шифрования.</P>
<P>При создании реальных криптосистем для работы с текстовыми файлами пригодны любые труднообратимые преобразования, отображающие множество [0..N-1] из N чисел в себя. Очень удобной представляется шифровальная схема немецкой криптографической машины «Энигма» («Загадка») инженера Артура Кирха [1, с. 69—75, 141—145], не устаревшая со времен Второй мировой войны. Ее электронная модель с большим числом шифровальных колес способна и сегодня нагнать тоску на криптоаналитиков из ФАПСИ.</P>
<P>В заключение заметим, что функция построчного шифрования успешно используется в многофункциональном и компактном (благодаря архиватору PKLITE) текстовом процессоре «Слово и Дело» («W&D») А. Е. Гутникова. К сожалению, автор не раскрывает алгоритм, ограничиваясь лишь заявлением о его криптостойкости. Однако, судя по скорости работы, используемый метод шифрования не очень сложен.  </P>

<H4>Литература</H4> 
<FONT SIZE=-1><I><OL><LI> Жельников В., Криптография от папируса до компьютера. М.: ABF, 1996.
<LI> Форсайт Дж., Малькольм М., Моулер К. Машинные методы математических вычислений /Пер. с англ. Х. Д. Икрамова. М.: Мир, 1980.
</OL></I></FONT>

<P>ОБ АВТОРЕ</P>
<P><B> Василий Текин</B> — инженер-программист городской клинической больницы № 23 г. Москвы. С ним можно связаться по телефону: (095) 915-71-83.</P>

<HR SIZE=1>

<A NAME="lis1"></a>
<H4>Листинг 1 </H4>
<PRE>
program DemoTest_1;
(***********************************)
(*Программа демонстрирует использование управляющих символов.*)
(* #07-^G - звонок (BEL);	*)
(* #08-^H - &lt;Backspace&gt; (BS); *)
(* #10-^J - перевод строки (LF); *)
(* #13-^M - возврат каретки (CR). *)
(***********************************)
const
  CR = #$0D;
  LF = #$0A;
  TempName = '$$$$$$$$.$$$';
type
  StringType = string [80];
  RegPack = record
    case boolean of
    False : (AX,BX,CX,DX,BP,SI,DI,DS,ES,Flags : integer);
    True : (AL,AH,BL,BH,CL,CH,DL,DH : byte)
  end;
var
  C : char;
  F : text;
  L : StringType;
(*--------------------------------------*)
procedure PutLine (Line : StringType);
(**********************)
(* Печать с задержкой *)
(**********************)
const
  Time = 150;
var
  I : byte;
  Regs : RegPack;
begin
  for I := 1 to Length (Line) do begin
    Regs.AH := $02; (* печать символа *)
    Regs.DL := Ord (Line [I]);
    MsDos (Regs);
    Delay (Time)
  end;
  WriteLn;
  Exit
end; (* PutLine *)
(*--------------------------------------*)
begin
  TextBackGround (Black);
  TextColor (LightGray);
  ClrScr;
  for C := #00 to #31 do begin
    Str (Ord (C) : 3, L);
    L := L + ' -&gt;' + C + '&lt;-';
    if C &gt; #15 then GotoXY (40, WhereY);
    PutLine (L);
    if C = #15 then GotoXY (1, 1)
  end;
  GotoXY (1, 18);
  Assign (F, TempName);
  Rewrite (F);
  WriteLn (F, 'Разорванная' + CR + LF + 'строка');
  WriteLn (F, 'Разорванная' + LF + CR + 'строка');
  WriteLn (F, 'Разорванная' + CR + 'строка');
  Close (F);
  Reset (F);
  while not Eof (F) do begin
    ReadLn (F, L);
    PutLine (L)
  end;
  Close (F);
  Erase (F);
  Halt
end. (* DemoTest_1 *)</PRE>

<HR>

<A NAME="lis2"></A>
<H4>Листинг 2</H4>
<PRE>
program CryptDemo_2;
(*********************************)
(*Шифрование строки текста случайной перестановкой символов.*)
(* Turbo Pascal 3.xx *)
(*********************************)
const
  TestTxt1 = 'Мама мыла Машу мылом. Маша мыло не любила. '#10;
  TestTxt2 = 'Шифрование перестановкой символов.';
  FileName = 'DEMO.TXT';
var
  I : byte;
  C : char;
  Line : string [$FF];
  CryptTab : array [1..255] of byte;
  F : text;
begin
  TextBackGround (Black);
  (* шифруемый текст *)
  Line := TestTxt1 + TestTxt2;
  TextColor (Yellow);
  WriteLn (Line);
  (* ввод-вывод строки через файл *)
  TextColor (LightGreen);
  Assign (F, FileName);
  Rewrite (F);
  WriteLn (F, Line);
  Close (F);
  Reset (F);
  ReadLn (F, Line);
  Close (F);
  Erase (F);
  WriteLn (Line);
  (* восстановление строки *)
  Line := TestTxt1 + TestTxt2;
  (* рандомизация ключа шифрования *)
  Randomize;
  (* подготовка таблицы перестановок *)
  for I := 1 to Length (Line) do
    CryptTab [I] := Succ (Random (Length (Line)));
  (* шифрование перестановкой символов *)
  for I := 1 to Length (Line) do begin
    C := Line [I];
    Line [I] := Line [CryptTab [I]];
    Line [CryptTab [I]] := C
  end;
  TextColor (LightCyan);
  WriteLn (Line);
  (* дешифрирование перестановки символов *)
  for I := Length (Line) downto 1 do begin
    C := Line [I];
    Line [I] := Line [CryptTab [I]];
    Line [CryptTab [I]] := C
  end;
  TextColor (White);
  Write (Line);
  TextColor (LightGray);
  Writeln;
  Halt
end. (* CryptDemo_2 *)
</PRE>

<HR>

<A NAME="lis3"></a>
<H4>Листинг 3 </H4>
<PRE>
program CryptDemo_3;
(****************************)
(*Шифрование строки текста заменой символов 32..255.*)
(* Turbo Pascal 3.xx *)
(****************************)
const
  TestTxt1 = 'Мама мыла Машу мылом. Маша мыло не любила. '#10;
  TestTxt2 = 'Шифрование заменой символов.';
var
  I : byte;
  C : char;
  Line : string [$FF];
  Shift : byte;
begin
  TextBackGround (Black);
  (* шифруемый текст *)
  Line := TestTxt1 + TestTxt2;
  TextColor (Yellow);
  WriteLn (Line);
  (* рандомизация ключа шифрования *)
  Randomize;
  Shift := 1 + Random (223);
  (* шифрование заменой символов *)
  for I := 1 to Length (Line) do
    if Line [I] &gt;= #32 then
      Line [I] := Chr ((Ord (Line [I]) + 192 - Shift) mod 224 + 32);
  TextColor (LightCyan);
  WriteLn (Line);
  (* дешифрирование замены символов *)
  for I := 1 to Length (Line) do
    if Line [I] &gt;= #32 then
      Line [I] := Chr ((Ord (Line [I]) - 32 + Shift) mod 224 + 32);
  TextColor (White);
  Write (Line);
  TextColor (LightGray);
  WriteLn;
  Halt
end. (* CryptDemo_3 *)</PRE>

<HR>

<A NAME="lis4"></a>
<H4>Листинг 4</H4>
<PRE>
program CryptDemo_4;
(**************************************)
(*Шифрование строк текста случайными сдвигами символов с кодами 32..255.*)
(* Turbo Pascal 3.xx *)
(**************************************)
const
  TestTxt1 = 'Мама мыла Машу мылом. Маша мыло не любила. '#10;
  TestTxt2 = 'Шифрование заменой символов.';
var
  I : byte;
  C : char;
  Line : string [$FF];
  ShiftTab : array [1..255] of byte;
begin
  TextBackGround (Black);
  (* шифруемый текст *)
  Line := TestTxt1 + TestTxt2;
  TextColor (Yellow);
  WriteLn (Line);
  (* рандомизация ключа шифрования *)
  Randomize;
  (* подготовка таблицы сдвигов *)
  for I := 1 to Length (Line) do
    ShiftTab [I] := Random (224);
  (* шифрование заменой символов *)
  for I := 1 to Length (Line) do
    if Line [I] &gt;= #32 then
      Line [I] := Chr ((Ord (Line [I]) + 192 -
                  ShiftTab [I]) mod 224 + 32);
  TextColor (LightCyan);
  WriteLn (Line);
  (* дешифрирование замены символов *)
  for I := 1 to Length (Line) do
    if Line [I] &gt;= #32 then
      Line [I] := Chr ((Ord (Line [I]) - 32 + ShiftTab [I])
                  mod 224 + 32);
  TextColor (White);
  Write (Line);
  TextColor (LightGray);
  WriteLn;
  Halt
end. (* CryptDemo_4 *)</PRE>

<HR>

<A NAME="lis5"></a>
<H4>Листинг 5</H4>
<PRE>
function RndWord (var Y : integer) : integer;
(********************************************)
(*Конгруэнтный генератор случайного слова.*)
(*Перед первым вызовом надо присвоить переменной Y целое
  и в дальнейшем его не изменять.*)
(********************************************)
begin
  Y := 12869 * Y + 6925;
  RndWord := Y;
  Exit
end; (* RndWord *)</PRE>

<HR>

<A NAME="lis6"></a>
<H4>Листинг 6</H4>
<PRE>
program CryptDemo_6;
(***************************************)
(* Шифрование строк текста сдвигами по паролю символов
   с кодами 32..255.*)
(* Turbo Pascal 3.xx *)
(***************************************)
const
  TestTxt1 = 'Мама мыла Машу мылом. Маша мыло не любила. '#10;
  TestTxt2 = 'Шифрование заменой символов.';
  PassWord : array [0..12] of char = 'Сов. секретно';
var
  I, J, K : byte;
  Line : string [$FF];
begin
  TextBackGround (Black);
  (* шифруемый текст *)
  Line := TestTxt1 + TestTxt2;
  TextColor (Yellow);
  WriteLn (Line);
  (* шифрование заменой символов *)
  for I := 1 to Length (Line) do
    if Line [I] &gt;= #32 then begin
      J := Ord (Line [I]) - 32;
      K := Ord (PassWord [I mod 13]) - 32;
      Line [I] := Chr ((J + 224 - K) mod 224 + 32)
    end;
  TextColor (LightCyan);
  WriteLn (Line);
  (* дешифрирование замены символов *)
  for I := 1 to Length (Line) do
    if Line [I] &gt;= #32 then begin
      J := Ord (Line [I]) - 32;
      K := Ord (PassWord [I mod 13]) - 32;
      Line [I] := Chr ((J + K) mod 224 + 32)
    end;
  TextColor (White);
  Write (Line);
  TextColor (LightGray);
  WriteLn;
  Halt
end. (* CryptDemo_6 *)</PRE>

<HR>

<A NAME="lis7"></a>
<H4>Листинг 7</H4>
<PRE>
program CryptDemo_7;
(****************************)
(*Шифрование строки текста заменой части символов.*)
(* Turbo Pascal 3.xx	*)
(****************************)
const
  TestTxt1 = 'Мама мыла Машу мылом. Маша мыло не любила. '#10;
  TestTxt2 = 'Шифрование заменой символов.';
var
  I : byte;
  C : char;
  Line : string [$FF];
  ShiftTab : array [1..255] of byte;
(*--------------------------------------*)
procedure ChangeCharNum (var C : char);
(************************)
(* Смена номера символа *)
(************************)
begin
  case C of
  #007..#010:	C := Chr (Ord (C) + 243);
  #013 :	C := #254;
  #026 :	C := #255;
  #250..#253:	C := Chr (Ord (C) - 243);
  #254 :	C := #013;
  #255 :	C := #026
  end;
  Exit
end; (* ChangeCharNum *)
(*--------------------------------------*)
begin
  TextBackGround (Black);
  (* шифруемый текст *)
  Line := TestTxt1 + TestTxt2;
  TextColor (Yellow);
  WriteLn (Line);
  (* рандомизация ключа шифрования *)
  Randomize;
  (* подготовка таблицы сдвигов *)
  for I := 1 to Length (Line) do
    ShiftTab [I] := Random (250);
  (* шифрование заменой символов *)
  for I := 1 to Length (Line) do begin
    ChangeCharNum (Line [I]);
    if Line [I] &lt; #250 then
      Line [I] := Chr ((Ord (Line [I]) + 250 - ShiftTab [I])
                  mod 250);
    ChangeCharNum (Line [I])
  end;
  TextColor (LightCyan);
  WriteLn (Line);
  (* дешифрирование замены символов *)
  for I := 1 to Length (Line) do begin
    ChangeCharNum (Line [I]);
    if Line [I] &lt; #250 then
      Line [I] := Chr ((Ord (Line [I]) + ShiftTab [I]) mod 250);
    ChangeCharNum (Line [I])
  end;
  TextColor (White);
  Write (Line);
  TextColor (LightGray);
  WriteLn;
  Halt
end. (* CryptDemo_7 *)</PRE>
<BR>

<!-- End: Content -->
<HR SIZE=1>
<b>
<A href="http://www.osp.ru/pcworld/2001/05/">Мир ПК, #05/2001</a>
</b>
<br>
Постоянный адрес статьи: <A href="http://www.osp.ru/pcworld/2001/05/048.htm">http://www.osp.ru/pcworld/2001/05/048.htm</a>
<br>
<br>

</DIV>
<!--#include virtual="/t_footer.htm"-->
