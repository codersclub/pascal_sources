<html><head><title>VGI 1.0 - Библиотека графического интерфейса</title>
<meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
<meta name="description" content='Vitus Graphic Interface - это библиотека функций для Turbo Pascal версии 5.0 и выше, позволяющая простыми средствами организовывать Lotus-подобный интерфейс пользователя как в текстовом, так и в графическом режиме.'>
<meta name="keywords" content="pascal, sources, source code, vgi10, graph, Графика ">
<LINK REL=STYLESHEET TYPE="text/css" HREF="../sources.css"></head><BODY><center>

<!--#include virtual="/t_hmenu.htm"-->


<div align='left'>&nbsp;&nbsp;&nbsp;<a class='title' href="index.htm">Графика</a>&nbsp&nbsp;&nbsp;&nbsp;<small>&gt;&gt;</small>&nbsp;&nbsp;&nbsp;&nbsp;vgi10
<br>&nbsp;&nbsp;&nbsp;<img border=0 height=4 width=50% align='top' src="../img/b.gif" alt="">
<br>&nbsp;
</div>


<TABLE cellSpacing=0 cellpadding=0 width=97% border=0>

<TR class=subheader><TD colSpan=3><IMG height=2 src="../img/1x1.gif" width=1></td></tr>
<TR><TD class=subheader width=70% nowrap>&nbsp;VGI 1.0 - Библиотека графического интерфейса</TD>
<TD nowrap class=black>&nbsp;<img border=0 align=bottom src="../img/mail.gif">&nbsp;<a href="mailto:vitus@fe.msk.ru">Виктор Вагнер</a></TD>
<TD class=black align='right'>12.05.1993</TD></TR>
<TR vALign=top><TD class=black>&#10;<p style="margin-left:20px">Vitus Graphic Interface - это библиотека функций
для Turbo Pascal версии 5.0 и выше, позволяющая простыми средствами
организовывать Lotus-подобный интерфейс пользователя
как в текстовом, так и в графическом режиме.</TD><TD class=black colspan=2 align='right'><br><A HREF="vgi10.zip"><img border=0 align=middle src="../img/dsk.gif"></A><br>18k&nbsp;</TD></TR><TR><TD>&nbsp;</TD></TR>

<TR class=subheader><TD colSpan=3><IMG height=2 src="../img/1x1.gif" width=1></td></tr>
<TR><TD colspan=3><PRE><p style="margin-left:50px">                    Vitus Graphic Interface
              Copyright (c) by Vitus B.Wagner,1992

                        В В Е Д Е Н И Е

    Vitus Graphic Interface - это библиотека функций для  Turbo
Pascal версии  5.0  и  выше,  позволяющая  простыми  средствами
организовывать  Lotus-подобный  интерфейс  пользователя  как  в
текстовом, так и в графическом режиме.
    VGI поддерживает все текстовые режимы,  графические  режимы
CGA 640х200 черно-белый, EGA и VGA 640х200,640х350 и 640х480 16
цветов.
    Для работы с VGI необходимы некоторые модули из  библиотеки
Turbo Profesional версии 5.05 и выше, а именно - в  графическом
режиме - только TPString, в текстовом - TPString,TPCrt,TPInline
и TPMouse.
   VGI состоит из модулей
     BgiInst,
     GrMouse,
     RusFont,
     VgiLo
  и  VgiHi.
Для работы в текстовом режиме требуется  только  модуль  VgiHi,
для работы в графическом - все модули  кроме  RusFont,  который
понадобится вам только в том случае, если вы захотите создавать
графические программы, не зависящие  от  наличия  в  компьютере
русского знакогенератора.

         У С Л О В И Я   Р А С П Р О С Т Р А Н Е Н И Я

   VGI - некоммерческий продукт, распространяемый на принцципах
freeware. Вы можете  использовать  его  для  собственных  нужд,
распространять и даже модифицировать. В случае  распространения
модифицированного продукта, не забудьте указать в  коментариях,
что имннно вы изменили.
   Если  же  вы  захотите  использовать   VGI   в   комерческих
программах, то вам необходимо связяться с автором и  обговорить
условия поставки коммерческой версии VGI.
   Автор заранее благодарен всем пользователям за  замечания  и
предложения по усовершенствованию, которые они  могут  сообщить
ему по адресу:
   Москва, 117334,
   Ленинский пр-кт,
   д 45 кв 176,
   Вагнеру Виктору.
или по телефону
   (095)135-46-61
--
Phone: 230-80-61                                Victor B.Wagner
E-Mail:vitus@agropc.msk.su                      Dokuchaev Soil Institute
                                                7, Pyzhevsky lane,
                                                Moscow, Russia

{&gt; Cut here. FileName= READ.ME }


                О П И С А Н И Е   М О Д У Л Е Й

Модуль VGIHI
------------
    Графический интерфейс высокого уровня.
Может компилироваться с двумя условными определениями:
 GraphMenu и MenuHelpLine
GraphMenu - задает режим работы - текстовый или графический.
MenuHelpLine  - немного усложняет вызов процедуры SimpleMenu,
но позволяет при этом выводить строку  подсказки  для  выбраной
позиции меню.
  Содержит константы
SaveOldContent : Boolean - если True, то после выхода из  меню,
оно исчезает с экрана  и  восстанавливается  старое  содержимое
этой области экрана.
BlinkRoutine : Pointer - если записать  сюда  адрес  процедуры,
описанной , например так :
       Procedure Blink(Item:byte),
и оттранслированной с ключом {$F+}, то в  эта  процедура  будет
постоянно вызываться в то  время  как  пользователь  производит
выбор из меню. Она может например заставить мигать какой-нибудь
графический объект  на  экране.  В  качестве  параметра  в  нее
передается номер текущей позиции меню.
SMenuHelpPtr - указатель на процедуру вызова  подсказки,  такую
же, как используемые в модулях Turbo Profesional .
Ее описание должно быть
Procedure Help(Id:byte;P:Pointer; Topic :Word);
Смысл параметров Id - код модуля . Для VGI он равен 7.
                 P - указатель на что-нибудь, что  поможет  вам
разобраться в какой момент была  вызвана  подсказка.  В  данном
случае - на строку меню.
Topic - номер  раздела  подсказки.  В  данном  случае  -  номер
текущей позиции меню.

    Процедуры и функции модуля VGIHi
function SimpleMenu - Вывод на  экран  горизонтального  меню  с
возможностью выбора стрелками или мышью.
Описание
 При трансляции без  директивы MenuHelpLine
function SimpleMenu (MenuString:String;- Текст меню,
                    MenuRow:Byte;      - Строка экрана
                    MenuAttr:byte;     - Аттрибут меню
                    SelectedAttr:byte  - Аттрибут курсора
                    ):ShortInt;

function SimpleMenu (MenuString:String;- Текст меню,
                     MenuRow:Byte;     - Строка экрана
                     MenuHelp:String;  - Текст подскказки
                     HelpRow:byte;     - Строка для подсказки
                     MenuAttr:byte;    - Аттрибут меню
                     SelectedAttr:byte;- Аттрибут курсора
                     HelpAttr:byte     - Атрибут подсказки.
                    ):ShortInt;
Строка меню может  быть  до  80  символов  в  длину.  Отдельные
позиции разделяются  символом  #0.  Строка  подсказки  устроена
также, но не имеет ограничений  на  длину.  Атрибуты  и  строки
экрана всегда передаются как в текстовом режиме.  Внимание!  Во
всех графических режимах VGI делит экран на 25 текстовых строк.
  Функция возвращает номер выбраной пользователем позиции меню,
если выбор был сделан клавишей Enter или  левой  клавишей  мыши
или номер со знаком  минус,  если  ползователь  нажал  Esc  или
правую клавишу.

Function SimplePick -  выбор  из  списка,  не  умещающегося  на
экран (например списка файлов текущего каталога)
Описание:
Function SimplePick(var PickSource;
                        PickSize:word;
                        PickRow:byte;
                        PickAttr:byte;
                        SelectedAttr:byte):word;
     Переменная  PickSource  содержит  то  же,  что  и   строка
MenuString- непрерывную последовательность символов,  отдельные
позиции в которой разделены нулевым символом,  но  может  иметь
размер до 32кбайт. PickSize - ее размер в байтах. Прерванная по
Esc, функция возвращает 0.
Function GetPickItem - извлекает из PickSource текст  указанной
позиции  по ее номеру.
Описание:
      Function GetPickItem ( Item : word  ;  var  PickSource  ;
PickSize : Word ) : string;

 Если вы использовали не Simplepick, a SimpleMenu, обратиттесь к ней
 так:
  GetPickItem(Item,MenuString[1],Length(MenuString));

Function PickFiles(pattern:String;var Fname:string;
                    Attr,SelAttr:Byte):byte;
     {По  заданному  шаблону  создает  меню   имен   файлов   и
возвращает в переменной FName выбранный файл. Если прервана  по
Esc, возвращает 0, иначе - ненулевой код}
Не умеет менять каталоги.

Function GetFile(var Flname:String;Extension:ExtStr):byte;
     Организует меню выбора файла такие же как в Lotus 1-2-3  -
с  возможностью  редактирования  начального  шаблона  ,   смены
каталогов и т.д.
Возвращает следующие коды:
  0 - файл найден
  1 - введено имя нового файла
  2 - прервано по Esc
  3 - ошибка.
Строка редактирования  всегда  в  первой  строке  экрана,  меню
файлов  -  во  второй.  Текст  приглашения  при  редвктировании
шаблона     задается     в     переменной     GetFilePrompt
Цвета задаются перемнными
GetFilePromptAttr - Приглашение при редактировании
GetFileEdit - редактироуемый шаблон имени
GetFileCursor - курсор при редактировании
GetFileList - список файлов
GetFileSelected - Курсор менюшки.

Procedure LineEdit - строчный редактор с эмуляцией  курсора  в
графическом режиме
Описание:
Procedure LineEdit
      (prompt:string;{Сопроводительный текст}
      var S:string;{Редактируемая строка}
      var Escaped:boolean;{True, если редактирование прервано клавишей Esc}
          SaveScreen:boolean;{True, если надо сохранить старое содержимое экрана}
          Row,Col, {Текстовые координаты начала Prompt}
          PromptAttr,TextAttr,CursorAttr:byte);{Цвета a la текстовый режим}

Кроме этого модуль содержит ряд процедур для  работы  с  мышью,
заменяющих аналогичные из  TPMouse  при  работе  в  графическом
режиме.

Модуль VGILo
------------

  Несколько полезных процедур для работы с графическим экраном
и процедуры ввода с  клавиатуры,  нужные  для  того,  чтобы  не
подключать CRT или TPCRT
Function SaveGraphWindow(X1,Y1,X2,Y2:integer;var p:pointer)
             :boolean;
     Сохраняет  в   динамической   области   содержимое   окна.
(координаты графические) Возвращает True, если операция удалась
и False в случае нехватки памяти

Procedure RestoreGraphWindow(X1,y1:word;var p:Pointer;
                           Deallocate:boolean);
     Восстанавливает  окно,  сохраненное   SaveGraphWindow. Если
Deallocate = True, освобождает память

Function SaveGraphSettings (var Save:pointer):boolean;
     Сохраняет в динамической области Практически все параметры
устанваливаетые в модуле Graph  (Цвет,  шаблон  закраски  номер
шрифта и т.д.) Возвращает True, если операция удалась и False в
случае нехватки памяти

Procedure  RestoreGraphSettings(Save:pointer;
                               Deallocate : boolean);
Восстанавливает параметры сохраненное Есл  Deallocate  =  True,
освобождает память

Function LoadFont (Filename:string):integer;
Загружает файл *.chr, который может  назодиться  не  в  текужем
каталоге. Возвращает номер шрифта, который нажно использовать
в SetTextStyle (положительные) или код ошибки из  модуля  Graph
(отрицательный)

procedure DisposeFont;
Освобождает  память,  занятую  шрифтом,  загруженным   функцией
LoadFont

procedure GrWrite(s:String;row,col,attr:byte);
Выводит строку в указанных текстовых  координатах  с  цветом  и
фоном заданным Attr

Function ReadKeyWord:Word;
Возвращает  слово,  младший  байт  которго  -  код  символа,  а
старший - скэнкод.

Function KeyPressed:Boolean ;
абсолютно аналогична функции из модуля CRT

Модуль BGIInst
--------------

  Содержит в себе файлы cga.bgi и egavga.bgi, что избавляет вас
от необходимости заботится о том, знает ли  программа,  где  их
искать. В операторе uses должен быть указан после модуля Graph.
Cодержит процедуры
procedure initgraph; - без параметров, а так то же, что и
   Graph.initgraph
procedure initcga; - включает графический режим CGA на EGA  или
VGA
procedure SetGraphMode(Mode:integer);     -      аналогична
Graph.SetGraphMode,     но     дополнительно     инициализирует
перечисленные ниже переменные.

Переменные модуля BGIInst
GraphDriver,GraphMode:integer;  -  позволяют  вашей   программе
узнать, в каком, собственно режиме она работает.
    GraphStringHeight:byte; - содержит  высоту  1/25  экрана  в
пикселах.

Модуль RusFont
--------------

    Не содержит ни одного объекта,  доступного  программам.  Но
если вы укажете его в операторе uses, то можете быть спокойны -
на любой машине в любом графическом режиме, поддерживаемом VGI,
русские буквы у вас будут.

Модуль GrMouse
--------------
    Простые процедуры работы с мышью в графическом режиме.

Function InitMouse:Boolean;

     Инициализирует мышь и  устанавливает  окно  мыши  на  весь
текущий экран ( не думайте что это тривиально - многие драйверы
мыши по умолчанию ставят окно 640х200). Возвращает Fаlse,  если
драйвер мыши не установлен. Во избежание ошибок  вызывайте  эту
функцию после перехода в графический режим.

procedure ReadMouse(var x,y:integer;var key:byte);

   Читает текущие координаты мыши (  в  пикселах)  и  состояние
клавиш. Переменная KEY устанавливается
в 0 если ни одна клавиша не нажата
  1 - нажата левая клавиша
  2 - нажата правая клавиша
  3 - нажаты обе клавиши
  4 - средняя
  5-7 комбинации средней с другими двумя.

 Procedure SetMouseXY( x,y:integer);

 Устанавливает курсор мыши в заданную позицию на экране.

procedure ShowMouse ;
procedure HideMouse ;

 Соответствено показывает и  прячет  курсор  мыши.Рекомендуется
прятать курсор мыши каждый раз, когда  вы  что-то  выводите  на
экран. Внимательно следите, чтобы каждому обращению к ShowMouse
соответствовало обращение к HideMouse.  В  отличие  от  TPMouse
проверок здесь нет.

procedure SetCursorShape(var Cursor : MouseCursorType ;
                           HotPointX , HotPointY : byte);
    Устанавливает форму курсора мыши.  Массив  Cursor  содержит
маски курсора и  экрана. Его тип описан как
type MouseCursorType = array [1..2,1..16] of word;
HotPointX и HotPointY -  координаты  горячего  пятна.  Что  это
такое - смотрите в руководствах по программированию для мыши.

Procedure SetMouseWindow (X1,y1,x2,y2:integer);

   Устанавливает пределы передвижения курсора.</PRE>

<!--#include virtual="/t_footer.htm"-->
