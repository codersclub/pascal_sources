<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><title>События - Программирование X Window средствами Free Pascal - Исходники.Ру</title>
<meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
<meta name="description" content='Курс лекций по программированию на FPC в X Window на платформе Unix. События.'>
<meta name="keywords" content="pascal, sources, source code, graph, kde, unix, window, графика ">
<LINK REL=STYLESHEET TYPE="text/css" HREF="/sources.css"></head><BODY><center>

<!--#include virtual="/t_hmenu.htm"-->


<div align='left'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class='blueb' href="/graph/index.htm">Графика</a>&nbsp&nbsp;&nbsp;&nbsp;<small>&gt;&gt;</small>
<br>&nbsp;&nbsp;&nbsp;<img border=0 height=4 width=50% align='top' src="/img/b.gif" alt="">
<br>&nbsp;
</div>


<TABLE cellSpacing=0 cellpadding=0 width=97% border=0>
<TR><TD colspan=3><p style="margin-left:50px">


<CENTER>
<H1>Программирование в X-Window
<br>средствами Free Pascal</H1>
Авторы: А.П. Полищук, С.А. Семериков
<BR>
[Оформление в HTML: <a class=blue href="mailto:rswag@sources.ru">Valery Votintsev</a>]
</CENTER>

<br>
<A class=blue HREF="../xwinfpc.htm">Содержание</a>

<br>
1. <A class=blue HREF="xbasics.htm">Основы программирования в системе X Window</A>
<BR>
1.1. <A class=blue HREF="basics.htm">Основные понятия</A>
<BR>
<hr>
<!-- begin CONTENT -->
<h2>1.1.7. События</A></h2>

<dir>

Когда пользователь нажимает на кнопку мыши или клавишу
клавиатуры, или когда окно программы нуждается в перерисовке, или когда
происходят другие изменения в системе, сервер подготавливает соответствующий
пакет данных и отправляет его той или иной программе (или программам). Этот
пакет данных называется <I>событием</I>.

<br>
<br>

Типичная GUI программа имеет следующую структуру:

<OL>
<LI>Выполняются инициализационные процедуры.</LI>
<LI>Устанавливается соединение с Х сервером.</LI>
<LI>Выполняются инициализационные процедуры, связанные с Х.</LI>
<LI>Пока не завершились:</LI>

<OL>
<LI>Получаем следующее событие от Х сервера.</LI>
<LI>Обрабатываем событие, возможно посылая различные
запросы на рисование к Х серверу.</LI>
<LI>Если событие было завершающим, заканчиваем
цикл.</LI>
</OL>

<LI>Закрываем соединение с Х сервером.</LI>
<LI>Выполняем завершающие действия.</LI></P>
</OL>
</OL>

Возможных событий достаточно много; их список можно найти в файле
<code>X.pp</code>. Каждое из них имеет свой тип и соответствующую
структуру данных. Все они вместе, как было сказано выше, описываются
объединением <code>XEvent</code>.

<br>
<br>

Как мы видели из примера в предыдущем пункте, программа
для каждого из своих окон может выбрать события, которые будут ему
передаваться. Делается это с помощью функции
<code>XSelectInput()</code>. При вызове этой процедуры требуемые события
идентифицируются соответствующими флагами. Так событию,
<code>ButtonPress</code> (нажатие кнопки мыши)
соответствует флаг
<code>ButtonPressMask</code>. Когда кнопка отпускается, сервер порождает
событие <code>ButtonRelease</code>, которому
соответствует флаг -
<code>ButtonReleaseMask</code>.

<br>
<br>

Маска выбираемых событий может составляться с помощью
побитового "ИЛИ" из таких значений:

<UL type=square>

<li>0</code> - не ожидать никаких событий</li>

<li><code>KeyPressMask</code> - ожидать событие нажатия клавиши</li>

<li><code>KeyReleaseMask</code> - ожидать событие отпускания клавиши</li>

<li><code>ButtonPressMask</code> - ожидать событие нажатия кнопки мыши</li>

<li><code>ButtonReleaseMask</code> - ожидать событие отпускания кнопки мыши</li>

<li><code>EnterWindowMask</code> - ожидать событие входа в окно</li>

<li><code>LeaveWindowMask</code> - ожидать событие выхода из окна</li>

<li><code>PointerMotionMask</code> - ожидать событие движения мышиного курсора</li>

<li><code>PointerMotionHintMask</code> - ожидать событие движения мышиного
курсора с дополнительными указаниями</li>

<li><code>Button1MotionMask</code> - ожидать событие движения мышиного
курсора при нажатой первой кнопке</li>

<li><code>Button2MotionMask</code> - ожидать событие движения мышиного
курсора при нажатой второй кнопке</li>

<li><code>Button3MotionMask</code> - ожидать событие движения мышиного
курсора при нажатой третьей кнопке</li>

<li><code>ButtonMotionMask</code> - ожидать событие движения мышиного
курсора при любой нажатой кнопке</li>

<li><code>ExposureMask</code> - ожидать событие необходимости
перерисовки окна</li>

<li><code>VisibilityChangeMask</code> - ожидать событие изменения видимости</li>

<li><code>ResizeRedirectMask</code> - ожидать событие изменения размеров окна</li>

<li><code>FocusChangeMask</code> - ожидать событие изменения фокуса ввода</li>

</ul>
<br>

Некоторые события посылаются окну независимо от того,
выбраны они или нет. Это:

<UL type=square>
<li><code>MappingNotify</code> - посылается, когда изменяется состояние
клавиатуры (соответствие физических и логических кодов;</li>

<li><code>ClientMessage</code> - так идентифицируются события,
посылаемые от клиента к клиенту с помощью процедуры
<code>XSendEvent()</code>;</li>

<li><code>SelectionClear</code>, <code>SelectionNotify</code>,
<code>SelectionRequest</code> - эти события используются в стандартном
механизме общения между программами, работающими в X;</li>

<li><code>Expose</code>, <code>NoExpose</code> - эти события могут посылаться,
когда клиент пытается копировать содержимое одного окна в другое.</li>

</ul>
<br>

Частой ошибкой начинающих программистов является
добавление кода для обработки нового события без добавления маски для этого
события в <code>XSelectInput()</code>. Можно
часам сидеть и отлаживать программу в недоумении, почему она не реагирует на
отпускание кнопки, только из-за того, что для кнопок событие нажатия
зарегистрировано, а событие отпускания - нет.

<br>
<br>

Программа получает события в своем основном цикле. Для
этого можно использовать ряд процедур. Наиболее простая из них -

<pre>
  Function XNextEvent(prDisplay : PDisplay;
                      prEvent : PXEvent) : longint;
                      cdecl; external;
</pre>

Она "вынимает" из очереди событие,
находящееся в ее "голове", сохраняет информацию о нем в переменной, на
которую указывает параметр
<code>prEvent</code>, и возвращается. При этом само событие удаляется из
очереди. Функция <code>XPeekEvent()</code>
также возвращает переданное сервером событие, но не удаляет его из
очереди.

<br>
<br>

Процедура <code>XPending()</code> возвращает общее число событий в очереди
программы.

<br>
<br>

Итак, если событие выбрано для окна, то оно будет передано
ему на обработку. А если нет? В этом случае событие передается родителю окна.
Если и тот не желает обращать внимание на данное событие, то оно отправляется
дальше, вверх по иерархии окон, и так до тех пор, пока либо не будет найдено
окно, выбравшее это событие, либо событие не потеряется.

<br>
<br>

Задача может влиять на этот процесс продвижения события по
иерархии окон. Если программа включает флаг, соответствующий событию, в
специальный атрибут окна, то оно, достигнув это окно, не будет передано
родителю, а будет тут же "снято с повестки дня". Этот атрибут -
<code>do_not_propagate</code>.

</dir>
<br>


<!-- end of CONTENT -->
<!--#include virtual="/t_footer.htm"-->
