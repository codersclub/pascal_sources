<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><title>Мышь - Программирование X Window средствами Free Pascal - Исходники.Ру</title>
<meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
<meta name="description" content='Курс лекций по программированию на FPC в X Window на платформе Unix. Работа с внешними устройствами. Мышь.'>
<meta name="keywords" content="pascal, sources, source code, graph, kde, unix, window, графика ">
<LINK REL=STYLESHEET TYPE="text/css" HREF="/sources.css"></head><BODY><center>

<!--#include virtual="/t_hmenu.htm"-->


<div align='left'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class='blueb' href="/graph/index.htm">Графика</a>&nbsp&nbsp;&nbsp;&nbsp;<small>&gt;&gt;</small>
<br>&nbsp;&nbsp;&nbsp;<img border=0 height=4 width=50% align='top' src="/img/b.gif" alt="">
<br>&nbsp;
</div>


<TABLE cellSpacing=0 cellpadding=0 width=97% border=0>
<TR><TD colspan=3><p style="margin-left:50px">


<CENTER>
<H1>Программирование в X-Window
<br>средствами Free Pascal</H1>
Авторы: А.П. Полищук, С.А. Семериков
<BR>
[Оформление в HTML: <a class=blue href="mailto:rswag@sources.ru">Valery Votintsev</a>]
</CENTER>

<br>
1. <A class=blue HREF="xbasics.htm">Основы программирования в системе X Window</A>
<BR>
1.3. <A class=blue HREF="keyboard.htm">Работа с внешними устройствами</A>
<BR>
<hr>
<!-- begin CONTENT -->
<h2>1.3.2. Мышь</h2>

<dir>

С точки зрения программы общение с мышью похоже на работу с клавиатурой.
X получает сигналы от устройства, преобразует их в события и помещает
последние в очередь программы. Однако есть и существенная разница.
Если события от клавиатуры передаются лишь программе,
окно которой имеет фокус ввода, то события от мыши могут передаваться,
в принципе, любой задаче, окно (окна) которой присутствуют на экране.

<br>
<br>

Чаще всего приходится обрабатывать события нажатия (отпускания) кнопки мыши.
Для регистрации такого типа событий, необходимо добавить
одну из следующих масок с помощью функции <code>XSelectInput()</code>:

<br>
<br>

<UL type=square>
<li><code>ButtonPressMask</code> - уведомлять о нажатии любой кнопки
в одном из окон программы.</li>
<li><code>ButtonReleaseMask</code> - уведомлять об отпускании любой кнопки
в одном из окон программы.
В цикле обработки сообщений могут проверяться такие события:</li>
<li><code>ButtonPress</code> - нажата кнопка в одном из окон программы.</li>
<li><code>ButtonRelease</code> - отпущена кнопка в одном из окон программы.</li>
</ul>
<br>

Структура для этих сообщений получается доступом к полю
<code>xbutton</code> объединения <code>TXEvent</code> и содержит,
в частности, такие поля:

<UL type=square>
<li><code>window : TWindow</code> - идентификатор окна, которому было
послано сообщение (в случае, если оно было зарегистрировано для
нескольких окон программы).</li>
<li><code>x, y : longint</code> - координаты x и y (в пикселях)
мышиного курсора в момент нажатия.</li>
<li><code>button : cardinal</code> - номер нажатой кнопки
(может принимать значения Button1, Button2, Button3).</li>
<li><code>time : TTime</code> - время (в миллисекундах),
которое длилось событие. Может использоваться для определения
"двойного щелчка".</li>
</ul>
<br>

В качестве примера приведем фрагмент кода, в котором рисуется черный
пиксель в позиции мыши всякий раз, когда мы получаем событие
"нажатие кнопки" от первой кнопки мыши, и стирается пиксель
(то есть рисуется белый), когда нажата вторая кнопка мыши.
Предполагается существование двух GC: gc_draw с черным цветом
переднего плана и gc_erase с белым цветом переднего плана.

<pre>
. . . . . .
ButtonPress:
begin
  (* сохраняем координаты кнопки мыши в целых переменных *)
  (* также сохраняем идентификатор окна, в котором была *)
  (* нажата кнопка мыши                 *)
  x := an_event.xbutton.x;
  y := an_event.xbutton.y;
  the_win := an_event.xbutton.window;

  (* проверяем, какая из кнопок была нажата, *)
  (* и действуем соответственно       *)
  case (an_event.xbutton.button) of
    Button1:
      (* рисуем пиксель в позиции мыши *)
      XDrawPoint(display, the_win, gc_draw, x, y);
    Button2:
      (* стираем пиксель в позиции мыши *)
      XDrawPoint(display, the_win, gc_erase, x, y);
    else (* возможно, третья кнопка - игнорируем *)
      ;
  end;
end;
. . . . . .
</pre>

Подобно событиям нажатия и отпускания кнопки мыши,
нас также могут извещать о различных событиях перемещения мыши.
Они делятся на два семейства. Первое - перемещение указателя мыши,
пока никакие кнопки не нажимаются, и второе - движение указателя мыши
при одной (или более) нажатых кнопках (это иногда называется операцией
"перетаскивания" (drag)). Следующие маски событий должны быть добавлены
в вызов <code>XSelectInput()</code> для получения извещений о таких
событиях:

<UL type=square>
<li><code>PointerMotionMask</code> - события указателя,
перемещающегося в одном из окон программы,
когда ни одна кнопка мыши не нажата.
</li>
<li><code>ButtonMotionMask</code> - события перемещения указателя,
пока одна (или более) кнопок мыши удерживается нажатой.
</li>
<li><code>Button1MotionMask</code> - тоже, что и <code>ButtonMotionMask</code>,
но только когда первая кнопка мыши удерживается нажатой.
</li>
<li><code>Button2MotionMask, Button3MotionMask, Button4MotionMask,
Button5MotionMask</code> - аналогично кнопок 2, 3, 4 или 5.
</li>
</ul>
<br>

В цикле обработки сообщений проверяется событие <code>MotionNotify</code> -
указатель мыши перемещался в одном из окон, для которых мы запросили
уведомление о таких событиях.
<br>
Структура для этих сообщений получается доступом к полю
<code>xmotion</code> объединения <code>TXEvent</code> и содержит,
в частности, такие поля:

<UL type=square>
<li><code>window : TWindow</code> - идентификатор окна,
которому было послано сообщение движения мыши
(в случае, если оно было зарегистрировано для нескольких окон программы).
</li>
<li><code>x, y : longint</code> - координаты x и y (в пикселях)
мышиного курсора в момент генерации сообщения.
</li>
<li><code>state : cardinal</code> - маска кнопок (или клавиш),
удерживаемых во время этого события (если таковые имеются).
Эта поле -побитовое "ИЛИ" любого из следующих значений:
<code>Button1Mask</code>, <code>Button2Mask</code>,
<code>Button3Mask</code>, <code>Button4Mask</code>,
<code>Button5Mask</code>, <code>ShiftMask</code>,
<code>LockMask</code>, <code>ControlMask</code>,
<code>Mod1Mask</code>, <code>Mod2Mask</code>,
<code>Mod3Mask</code>, <code>Mod4Mask</code>,
<code>Mod5Mask</code>.
<br>
Первые пять значений ссылаются на кнопки мыши, которые нажимаются,
остальные соответствуют различным специальным клавишам
(<code>Mod1</code> - обычно клавиша <code>Alt</code> или
<code>Meta</code>).
</li>
<li><code>time : TTime</code> - время (в миллисекундах),
которое длилось событие.
</li>
</ul>
<br>

Как пример, следующий код определяет режим рисования для
графического редактора, в котором, если пользователь перемещает мышь,
удерживая первую ее кнопку, мы рисуем на экране.
Этот код имеет недостаток: поскольку перемещение мыши может
генерировать много событий, вполне возможно, что мы не получим
событие движения мыши для каждого пикселя, над которым проходит мышь.
Один из способов разрещения этой ситуации состоит в запоминании
последнего пикселя, над которым была "протащена" мышь,
и рисованием линии между запомненной и новой позициями указателя мыши.

<pre>
. . . . . .
MotionNotify:
begin
  (* сохраняем координаты кнопки мыши в целых переменных *)
  (* также сохраняем идентификатор окна, в котором была *)
  (* протащена мышь                   *)
  x := an_event.xmotion.x;
  y := an_event.xmotion.y;
  the_win := an_event.xbutton.window;

  (* если первая кнопка мыши удерживалась во время этого события, *)
  (*<code> рисуем пиксель в позиции мышиного курсора *)
  if (an_event.xmotion.state AND Button1Mask) then begin
    XDrawPoint(display, the_win, gc_draw, x, y);
  end;
end;
. . . . . .
</pre>

Другой тип мышиных событий - вход указателя мыши в окно программы
или выход из окна. Некоторые программы используют эти события,
чтобы показать пользователю, что приложение получило фокус.
Для регистрации событий этого типа необходимо добавить один
(или более) из следующих масок в функции <code>XSelectInput()</code>:

<UL type=square>
<li><code>EnterWindowMask</code> - уведомлять, когда указатель мыши
входит в любое из окон программы.</li>
<li><code>LeaveWindowMask</code> - уведомлять, когда указатель мыши
выходит из окна программы.</li>
</ul>
<br>

В цикле обработки сообщений проверяется одно из следующих событий:

<UL type=square>
<li><code>EnterNotify</code> - указатель мыши только что вошел
в одно из окон программы.</li>
<li><code>LeaveNotify</code> - указатель мыши только что вышел
из окна программы.</li>
</ul>
<br>

Структура для этих сообщений получается доступом к полю
<code>xcrossing</code> объединения <code>TXEvent</code> и содержит,
в частности, такие поля:

<UL type=square>
<li><code>window : TWindow</code> - идентификатор окна,
которому было послано сообщение от мыши
(в случае, если оно было зарегистрировано для нескольких окон программы).</li>
<li><code>subwindow : TWindow</code> - идентификатор дочернего окна,
из которого мышь перешла в текущее (в событии <code>EnterNotify</code>),
или в которое указатель мыши переместился
(в событии <code>LeaveNotify</code>), или <code>None</code>,
если мышь переместилась за пределы окон программы.</li>
<li><code>x, y : longint</code> - координаты x и y (в пикселях)
мышиного курсора в момент генерации сообщения.</li>
<li><code>mode : longint</code> - номер нажатой кнопки
(может принимать значения Button1, Button2, Button3).</li>
<li><code>time : TTime</code> - время (в миллисекундах),
которое длилось событие. Может использоваться для определения
"двойного щелчка".</li>
<li><code>state : cardinal</code> - маска кнопок (или клавиш),
удерживаемых во время этого события (если таковые имеются).
Эта поле - побитовое "ИЛИ" любого из следующих значений:
<code>Button1Mask, Button2Mask, Button3Mask, Button4Mask,
Button5Mask, ShiftMask, LockMask, ControlMask,
Mod1Mask, Mod2Mask, Mod3Mask, Mod4Mask, Mod5Mask</code>.
<br>
Первые пять значений ссылаются на кнопки мыши, которые нажимаются,
остальные соответствуют различным специальным клавишам
(<code>Mod1</code> - обычно клавиша <code>Alt</code> или
<code>Meta</code>).</li>
<li>focus : TBool</code> - устанавливается в <code>True</code>,
если окно имеет клавиатурный фокус, и <code>False</code>
в противном случае.</li>
</ul>
<br>

Обычно фокус ввода может свободно переходить от окна к окну.
Но иногда программе необходимо запретить передачу фокуса.
Это называется захватом клавиатуры. Для того, чтобы его реализовать,
используется процедура <code>XGrabKeyboard()</code>.

<br>
<br>

Функция <code>XGrabKey()</code> запрещает передачу фокуса после нажатия
определенной комбинации клавиш. Освободить клавиатуру можно,
обратившись к процедуре <code>XUngrabKeyboard()</code>
(<code>XGrabKey()</code>).

<br>
<br>

Рассмотрим поведение системы при обработке событий от мыши.
Как правило, если ее кнопка нажата в момент,
когда ее курсор находится в неактивном окне,
то последнее активизируется, и события от мыши передаются ему.
Сказанное означает, что в нормальном состоянии окно получает
только те события от мыши, которые соответствуют сигналам,
пришедшим тогда, когда ее курсор находится в пределах окна.
Но если программа вызывает

<pre>
Function XGrabPointer(prDisplay : PDisplay; nGrabWnd : TWindow; 
                      nOwnerEvents : TBool; nEventMask : cardinal;
                      nPointerMode : longint; nKeyboardMode : longint;
                      nConfineTo : TWindow; nCursor : TCursor;
                      nTime : TTime) : longint; cdecl;external;
</pre>

то положение меняется. Теперь все события будут направляться окну
с дескриптором <code>nGrabWnd</code>. Освобождается мышь вызовом
<code>XUngrabPointer()</code>. Процедура <code>XGrabButton()</code>
указывает, что курсор должен быть захвачен после нажатия определенной кнопки.
Обратной к ней является процедура <code>XUngrabButton()</code>.

<br>
<br>

Процедуры, захватывающие устройство, - мышь или клавиатуру -
имеют ряд аргументов, влияющих на поведение системы.

<br>
<br>

Так, параметр <code>nConfineTo</code> есть идентификатор окна,
за пределы которого не должен выходить курсор мыши, если он захвачен.

<br>
<br>

Если аргумент <code>nOwnerEvents</code> равен <code>Тrue</code>,
то события мыши будут передаваться окнам программы.
Если <code>nOwnerEvents</code> - <code>False</code>,
или курсор находится в окне, не принадлежащем программе,
то события мыши передаются окну <code>nGrabWnd</code>.

<br>
<br>

Если <code>nOwnerEvents</code> равен <code>False</code>, то параметр
<code>nEventMask</code> указывает, какие события следует передавать
окну <code>nGrabWnd</code>.

<br>
<br>

Обработка событий от клавиатуры или ныши может быть приостановлена,
если <code>nPointerMode</code> или <code>nKeyboardMode</code> равен
<code>GrabModeSync</code>. В этом случае события буферизуются сервером,
пока устройство не будет освобождено с помощью <code>XUngrabKeyboard()</code>,
<code>XUngrabKey()</code>, <code>XUngrabPointer()</code> или
<code>XUngrabButton()</code>.

<br>
<br>

Параметр <code>nCursor</code> задает форму курсора во время того,
как мышь захвачена. Аргумент <code>nTime</code> указывает,
когда система должна активизировать режим захвата.

</dir>
<br>


<!-- end of CONTENT -->
<!--#include virtual="/t_footer.htm"-->
