<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><title>Битовые и пиксельные карты - Программирование X Window средствами Free Pascal - Исходники.Ру</title>
<meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
<meta name="description" content='Курс лекций по программированию на FPC в X Window на платформе Unix. Битовые и пиксельные карты.'>
<meta name="keywords" content="pascal, sources, source code, graph, kde, unix, window, графика ">
<LINK REL=STYLESHEET TYPE="text/css" HREF="/sources.css"></head><BODY><center>

<!--#include virtual="/t_hmenu.htm"-->


<div align='left'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class='blueb' href="/graph/index.htm">Графика</a>&nbsp&nbsp;&nbsp;&nbsp;<small>&gt;&gt;</small>
<br>&nbsp;&nbsp;&nbsp;<img border=0 height=4 width=50% align='top' src="/img/b.gif" alt="">
<br>&nbsp;
</div>


<TABLE cellSpacing=0 cellpadding=0 width=97% border=0>
<TR><TD colspan=3><p style="margin-left:50px">


<CENTER>
<H1>Программирование в X-Window
<br>средствами Free Pascal</H1>
Авторы: А.П. Полищук, С.А. Семериков
<BR>
[Оформление в HTML: <a class=blue href="mailto:rswag@sources.ru">Valery Votintsev</a>]
</CENTER>

<br>
<A class=blue HREF="../xwinfpc.htm">Содержание</a>

<br>
1. <A class=blue HREF="xbasics.htm">Основы программирования в системе X Window</A>
<BR>
1.2. <A class=blue HREF="gr_text.htm">Текст и графика</A>
<BR>
<hr>
<!-- begin CONTENT -->
<h2>1.2.5. Битовые и пиксельные карты</h2>

<dir>

Xlib не имеет никаких средств для работы с популярными
графическими форматами, такими как gif, jpeg или tiff. На программиста
(или высокоуровневые графические библиотеки) оставлен перевод эти форматы
изображений в форматы, с которыми знаком X сервер - битовыми и
пиксельными картами.

<br>
<br>

<I>Битовая карта X</I> - двухцветное
изображение, сохраненное в формате, специфическом для X Window.
Сохраненные в файле, данные битовой карты выглядят похожими на исходный файл
на языке C. Он содержит переменные, определяющие ширину и высоту битового
изображения, массив, содержащие битовые величины битового изображения (размер
массива равен произведению ширины на высоту), и позицию горячей точки
(опционально).

<br>
<br>

<I>Пиксельная карта X</I> - формат,
используемый для хранения изображений в памяти Х сервера. Этот формат может
сохранять как черно-белые изображения (те же битовые карты), так и цветные
изображения. Это единственный графический формат, поддерживаемый протоколом
X, и любое изображение, которое должно рисоваться на экране, должно сначала
быть переведено в этот формат.

<br>
<br>

В действительности, пиксельная карта X может трактоваться
как окно, которое не появляется на экране. Многие графические операции,
которые работают в окнах, точно также будут работать в пиксельных картах -
достаточно подставить дескриптор пиксельной карты вместо дескриптора окна. В
страницах справочного руководства видно, что все эти функции принимают
<code>TDrawable</code>, не
<code>TWindow</code>, поскольку как окна так и пиксельные
карты - рисуемые элементы, и они оба могут использоваться, чтобы рисовать в
них такими функциями, как, например,
<code>XDrawArc()</code>, <code>XDrawText(),</code>
и т.п.

<br>
<br>

Один из способов загрузки битового изображение из файла в
память - включение файла побитового изображения в программу директиву
<code>#include</code> препроцессора языка С.
Покажем, как можно получить доступ к файлу непосредственно:

<pre>
var
  (* эта переменная будет содержать дескриптор новой пиксельной карты *)
  bitmap : TPixmap;

  (* эти переменные будут содержать размер загружаемой битовой карты *)
  bitmap_width, bitmap_height : word;

  (* эти переменные будут содержать положение горячей точки *)
  ((* загружаемой битовой карты               *)
  hotspot_x, hotspot_y : integer;

  (* эта переменная будет содержать дескриптор корневого окна экрана, *)
  (* для которого мы хотим создать пиксельную карту          *)
  root_win : TWindow;
  rc : longint;

  root_win := XDefaultRootWindow(display);

  (* загружаем битовую карту из файла "icon.bmp", создаем *)
  (* пиксельную карту, содержащую свои данные в сервере, *)
  (* и сохраняем ее дескриптор в переменной bitmap    *)
  rc := XReadBitmapFile(display, root_win,
             'icon.bmp',
             @bitmap_width, @bitmap_height,
             @bitmap,
             @hotspot_x, @hotspot_y);
  (* проверяем, удалось ли создать пиксельную карту *)
  case (rc) of 
    BitmapOpenFailed:
      writeln('XReadBitmapFile - не могу открыть файл "icon.bmp"');
    BitmapFileInvalid:
      writeln('XReadBitmapFile - файл "icon.bmp" не содержит '+
              'корректного битового изображения.');
    BitmapNoMemory:
      writeln('XReadBitmapFile - не хватает памяти.');
    BitmapSuccess:
      (* битовая карта успешно загружена - что-то делаем с ней... *)
    .
    .
  end;
</pre>

Имейте в виду, что параметр
<code>root_win</code> не имеет ничего общего с данным битовым
изображением - битовая карта не связывается с этим окном. Этот дескриптор
окна использован только для определения экрана, для которого мы хотим создать
пиксельную карту. Это существенно, так как для того, чтобы быть полезной,
пиксельная карта должна поддерживать то же количество цветов, что и экран
делает.

<br>
<br>

Как только мы получили дескриптор пиксельной карты,
сгенерированный из битового изображения, мы можем нарисовать ее в некотором
окне, используя функцию
<code>XCopyPlane()</code>. Эта функция позволяет указать, в какой рисуемой
области (окне, или даже другой пиксельной карте) и в какой позиции будет
отображена данная пиксельная карта.

<pre>
(* Рисовать ранее загруженную битовую карту в заданном окне, в  *)
(* позиции x=100, y=50. Мы хотим скопировать всю битовую карту, *)
(* поэтому указываем координаты x=0, y=0 для копирования с      *)
(* начала битового изображения и его полный размер              *)
XCopyPlane(display, bitmap, win, gc,
     0, 0,
     bitmap_width, bitmap_height,
     100, 50,
     1);
</pre>

Мы могли также скопировать заданный прямоугольный фрагмент пиксельной
карты вместо полного ее копирования. Последний параметр в функции
<code>XCopyPlane()</code> определяет, какой слой (цветовую плоскость)
исходного изображения мы хотим скопировать в целевое окно.
Для битовых изображений всегда копируется плоскость номер 1.

<br>
<br>

Часто бывает необходимо создать неинициализированную пиксельную карту,
чтобы в дальнейшем в ней можно было рисовать.
Это полезно для графических редакторов (создание нового пустого
"холста" вызовет создание новой пиксельной карты, в которой будет
храниться изображение). Это полезно при чтении различных форматов
изображений - мы загружаем графические данные в память,
создаем на сервере пиксельную карту, а затем рисуем расшифрованный
графические данные на этот пиксельной карте.

<pre>
var
  (* эта переменная будет содержать дескриптор новой пиксельной карты *)
  pixmap : TPixmap;

  (* эта переменная будет содержать дескриптор корневого окна экрана, *)
  (* для которого мы хотим создать пиксельную карту          *)
  root_win : TWindow;

  (* эта переменная будет содержать глубину цвета создаваемой *)
  (* пиксельной карты - количество бит, используемых для   *)
  (* представления индекса цвета в палитре (количество цветов *)
  (* равно степени двойки глубины)              *)
  depth : longint;

  root_win := XDefaultRootWindow(display);
  depth := XDefaultDepth(display, XDefaultScreen(display));

  (* создаем новую пиксельную карту шириной 30 и высотой в 40 пикселей *)
  pixmap := XCreatePixmap(display, root_win, 30, 40, depth);

  (* для полноты ощущений нарисуем точку в центре пиксельной карты *)
  XDrawPoint(display, pixmap, gc, 15, 20);
</pre>

После получения дескриптора пиксельной карты мы можем
отобразить ее в некотором окне, используя функцию <code>XCopyArea()</code>.
Эта функция позволяет указать устройство рисования (окно или даже другую
пиксельную карту) и в какое позиция этого устройства пиксельная карта будет
отображена.

<pre>
(* Рисовать ранее загруженную битовую карту в заданном окне, в *)
(* позиции x=100, y=50. Мы хотим скопировать всю битовую карту, *)
(* поэтому указываем координаты x=0, y=0 для копирования с   *)
(* начала битового изображения и его полный размер       *)
XCopyArea(display, bitmap, win, gc,
     0, 0,
     bitmap_width, bitmap_height,
     100, 50);
</pre>

Мы могли также скопировать заданный прямоугольный фрагмент
пиксельной карты вместо полного ее копирования.

<br>
<br>

Отметим, что на одном и том же экране возможно создавать
пиксельные карты различных глубин. Когда мы выполняем операции копирования
(пиксельной карты в окно и т.п.), мы должны убедиться, что источник и
приемник имеют одну и ту же глубину. Если их глубина различается, операция не
удастся. Единственное исключение - копирование указанной битовой плоскости
пиксельной карты с помощью показанной ранее функции
<code>XCopyPlane()</code>. В этом случае мы можем
скопировать указанную плоскость в окно-приемник - в действительности
устанавливается указанный бит в цвете каждого копируемого пикселя. Это может
быть использовано для создания забавных графических эффектов.

<br>
<br>

Наконец, когда все операции над данной пиксельной картой
выполнены, ее необходимо освободить, чтобы освободить ресурсы Х сервера. Это
делается с помощью функции
<code>XFreePixmap()</code>:

<pre>
(* освобождение пиксельной карты с заданным дескриптором *)
XFreePixmap(display, pixmap);
</pre>

</dir>
<br>


<!-- end of CONTENT -->
<!--#include virtual="/t_footer.htm"-->
