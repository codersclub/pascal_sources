<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><title>Работа с внешними устройствами - Программирование X Window средствами Free Pascal - Исходники.Ру</title>
<meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
<meta name="description" content='Курс лекций по программированию на FPC в X Window на платформе Unix. Работа с внешними устройствами. Клавиатура.'>
<meta name="keywords" content="pascal, sources, source code, graph, kde, unix, window, графика ">
<LINK REL=STYLESHEET TYPE="text/css" HREF="/sources.css"></head><BODY><center>

<!--#include virtual="/t_hmenu.htm"-->


<div align='left'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class='blueb' href="/graph/index.htm">Графика</a>&nbsp&nbsp;&nbsp;&nbsp;<small>&gt;&gt;</small>
<br>&nbsp;&nbsp;&nbsp;<img border=0 height=4 width=50% align='top' src="/img/b.gif" alt="">
<br>&nbsp;
</div>


<TABLE cellSpacing=0 cellpadding=0 width=97% border=0>
<TR><TD colspan=3><p style="margin-left:50px">


<CENTER>
<H1>Программирование в X-Window
<br>средствами Free Pascal</H1>
Авторы: А.П. Полищук, С.А. Семериков
<BR>
[Оформление в HTML: <a class=blue href="mailto:rswag@sources.ru">Valery Votintsev</a>]
</CENTER>

<br>
<A class=blue HREF="../xwinfpc.htm">Содержание</a>

<br>
1. <A class=blue HREF="xbasics.htm">Основы программирования в системе X Window</A>
<BR>
<hr>
<!-- begin CONTENT -->
<h2>1.3. Работа с внешними устройствами</h2>

<dir>

<h3>1.3.1. Клавиатура</h3>

Как и большинство интерактивных программ, задачи,
выполняющиеся в X Window, активно используют для ввода информации клавиатуру
компьютера. Когда пользователь нажимает или отпускает клавишу, сервер
получает соответствующий сигнал, который преобразуется в событие и
отправляется в очередь программы, имеющей фокус ввода (input focus).

<br>
<br>

Поясним, что такое фокус ввода. Дело в том, что клавиатура
у машины одна, и она разделяется всеми выполняющимися одновременно
программами. Но в каждый момент времени поступающий от устройства сигнал
доступен лишь одной из них, как правило, той, которой принадлежит активное
окно. В этом случае говорят, что программа и ее окно имеют <I>фокус
ввода</I>. Последний может переходить от окна к окну и от программы к
программе.

<br>
<br>

Когда окно получает фокус, соответствующей программе
посылается событие <code>FocusIn</code>, при
потере - приходит событие
<code>FocusOut</code>.

<br>
<br>

Когда пользователь нажимает клавишу клавиатуры, программа
получает событие <code>KeyPress</code>.
Сервер также может послать событие
<code>KeyRelease</code>, когда клавиша отпускается, но это справедливо не
для всех типов компьютеров.

<br>
<br>

Оба этих события сопровождаются структурой типа
<code>TXKeyEvent</code>. Ее поле
<code>keycode</code> содержит код нажатой
клавиши, а поле <code>state</code> -
состояние клавиш-модификаторов и кнопок мыши. Модификаторами называются такие
клавиши, как <code>Shift</code>,
<code>Ctrl</code>, <code>Caps&nbsp;Lock</code>.
Кроме этого, X предусматривает наличие дополнительных
модификаторов, которые обозначаются
<code>Mod1</code>, ..., <code>Mod5</code>. Каждой
нажатой клавише-модификатору и кнопке мыши соответствует флаг в поле
<code>state</code>.

<br>
<br>

Коды, передаваемые через поле
<code>keycode</code> структуры
<code>TXKeyEvent</code>, однозначно идентифицируют клавиши. Их конкретные
значения зависят от типа машины и клавиатуры. Эти коды мы будем называть
<I>физическими</I>. Чтобы обеспечить переносимость программ, сервер
устанавливает соответствие между физическими кодами клавиш, которые могут
меняться от компьютера к компьютеру, и целочисленными константами -
<I>логическими</I> кодами (символами). Они имеют предопределенные значения,
которые приведены в файле
<code>/usr/include/X11/keysymdef.h</code> и начинаются с префикса
"<code>XK_</code>". Так, букве
"a" соответствует символ
<code>XK_a</code>, клавише
&lt;Return&gt; (&lt;Enter&gt;) - символ
<code>XK_Return</code> и т.д.

<br>
<br>

Для разных алфавитов X поддерживает разные множества
логических кодов. Возможные типы алфавитов перечисляются в файле
<code>/usr/include/X11/keysym.h</code>.

<br>
<br>

Одному коду клавиши может соответствовать несколько
символов в зависимости от состояния клавиш-модификаторов. Функция

<pre>
Function XKeycodeToKeysym(prDisplay : PDisplay;nKeycode : TKeyCode;
                          nIndex : longint) : TKeySym; cdecl;external;
</pre>

позволяет по коду <code>nKeyCode</code> получить соответствующий ему
символ с номером <code>nIndex</code>. Если
<code>nIndex</code> равен 0, то полученный символ соответствует
просто нажатой клавише. Если
<code>nIndex</code> равен 1, то возвращается символ,
соответствующий ситуации, когда клавиша нажата одновременно с
<code>Shift</code>.

<br>
<br>

Функция <code>XKeysymToKeycode()</code> осуществляет обратное
преобразование.

<br>
<br>

Программа может получить карту соответствия кодов и символов,
обратившись к процедуре <code>XGetKeyboardMapping()</code>.

<br>
<br>

Изменяется соответствие физических и логических кодов процедурой
<code>XChangeKeyboardMapping()</code>.
Следующая последовательность операторов ставит клавише
<code>&lt;F2&gt;</code> в соответствие символ
<code>XK_F3</code>.

<pre>
........
var
  nF2Sym, nF3Sym : TKeysym;
  nF2Keycode : TKeyCode;
  prDisplay : PDisplay;
........
  nF2Sym     := XStringToKeysym ("F2");
  nF3Sym     := XStringToKeysym ("F3");
  nF2Keycode := XKeysymToKeycode (prDisplay, nF2Sym);
  XChangeKeyboardMapping (prDisplay, nF2Keycode, 1, @nF3Sym, 1);
........
</pre>

Здесь использована процедура
<code>XStringToKeysym()</code>, которая по строке
"<code>str</code>" возвращает соответствующий символ
<code>XK_str</code>.

<br>
<br>

Когда соответствие кодов меняется, всем работающим в
настоящее время клиентам посылается событие
<code>MappingNotify</code>.

<br>
<br>

Клавиши-модификаторы также имеют логические коды. Клавишам
<code>Shift</code> сопоставлены
символы <code>XK_Shift_L</code> и
<code>XK_Shift_R</code>;
<code>Caps Lock</code> соответствует
<code>XK_CapsLock</code>; <code>Control</code> -
<code>XK_Control_L</code>;
<code>Mod1</code> - <code>XK_Meta_L</code> и
<code>XK_Meta_R</code>. Символы остальных
модификаторов (<code>Mod2</code> -
<code>Mod5</code>) не определены. X содержит набор
специальных процедур, которые позволяют получить и установить соответствие
код-символ для модификаторов. Эти функции следующие:

<code>XGetModifierMapping(),
XInsertModifiermapEntry(),
XDeleteModifiermapEntry(),
XSetModifierMapping()</code>.

<br>
<br>

X не останавливается на задании соответствия код клавиши -
символы, а идет дальше. Система позволяет программе сопоставить любой
комбинации модификаторов и клавиш (например,
<code>&lt;Shift+Ctrl+A&gt;</code>) ASCII строку (например,
"<code>EXIT</code>"). Для некоторых клавиш соответствующие
строки задаются сервером по умолчанию. Так, символу
<code>XK_A</code> соответствует строка
"<code>A</code>".

<br>
<br>

Макрос
<code>XRebindKeysym()</code> берет символ, список модификаторов и
сопоставляет им строку.

<br>
<br>

Процедура
<code>XLookupString()</code>, наоборот, берет событие о нажатии (отпускании)
клавиши и возвращает соответствующие ему символ и строку. Последний ее
параметр - указатель на структуру типа
<code>XComposeStatus</code>. Дело в том, что некоторые клавиатуры имеют
специальную клавишу <code>Compose</code>,
которая позволяет печатать символы, которым нет соответствия среди клавиш.
Специальная таблица указывает, какой символ должен быть создан, если обычна
клавиша нажимается одновременно с
<code>Compose</code>. Ссылка на эту информацию и возвращается в структуре
<code>XComposeStatus</code>.

<br>
<br>

Ниже приводится фрагмент программы, которая распознает
функциональные клавиши
<code>&lt;F1&gt;-&lt;F5&gt;</code>, и при их нажатии печатает
соответствующую строку. Программа также сопоставляет комбинации
<code>&lt;Shift+Control+A&gt;</code> строку
"<code>EXIT</code>". Эта комбинация используется для
завершения программы.

<pre>
........
var
  prDisplay : PDisplay;
  nScreenNum : integer;
  prGC : TGC;
  rEvent : TXEvent;
  nWnd : TWindow;
  sKeyStr : array [0..19] of char;
  nKeySym : TKeySym;
  naModList : array [0..1] of TKeySym;
  n : integer;
  r: char;

const
  XK_Control_L=$FFE3; (* Left control *)
  XK_Shift_L=$FFE1;   (* Left shift *)
  XK_F1=$FFBE;
  XK_F2=$FFBF;
  XK_F3=$FFC0;
  XK_F4=$FFC1;
  XK_F5=$FFC2;
  XK_F6=$FFC3;

  (* Устанавливаем связь с сервером, получаем номер экрана . . . *)
  .........
  (* Задаем соответствие символ-строка *)
  naModList[0] := XK_Control_L;
  naModList[1] := XK_Shift_L;
  XRebindKeysym (prDisplay, XK_F6, naModList, 2, 'EXIT',
                 strlen('EXIT'));
  (* Цикл получения и обработки событий *)

  while true do begin
    XNextEvent (prDisplay, @rEvent);
    case (rEvent.eventtype) of
       ......
      KeyPress :
      begin
        (* Очищаем строку *)
        for n:=0 to 19 do
          sKeyStr[n]:=#0;

        (* Получаем строку, соответствующую событию *)
        XLookupString (@rEvent.xkey, sKeyStr, 20, @nKeySym, NIL);
        if ( strcomp (sKeyStr, 'EXIT')=0 ) then
        begin
          XFreeGC (prDisplay, prGC);
          XCloseDisplay (prDisplay);
          halt (0);
        end;

        case nKeySym of
          XK_F1: r:='1';
          XK_F2: r:='2';
          XK_F3: r:='3';
          XK_F4: r:='4';
          XK_F5: r:='5';
          else r:='0';
        end;

        if (n&lt;&gt;0) then begin
          sKeyStr[0]:='F';
          sKeyStr[1]:=r;
          sKeyStr[2]:=#0;
          strcat(sKeyStr, ' pressed.');
          XClearWindow (prDisplay, nWnd);
          XDrawString (prDisplay, nWnd, prGC, 10, 50,
                       sKeyStr, strlen (sKeyStr));
        end;
      end;
  end;
end;
........
</pre>

Сервер имеет ряд атрибутов, воздействующих на обработку сигналов клавиатуры.
Получить их можно с помощью функции
<code>XGetKeyboardControl()</code>.
Она возвращает указанные параметры в переменной, имеющей тип
<code>TXKeyboardState</code>, определенный следующим образом:

<pre>
TXKeyboardState = record
     key_click_percent : longint;
     bell_percent : longint;
     bell_pitch : cardinal;
     bell_duration : cardinal;
     led_mask : cardinal;
     global_auto_repeat : longint;
     auto_repeats : array[0..(32)-1] of char;
  end;
PXKeyboardState = ^TXKeyboardState;
</pre>

Поле <code>key_click_percent</code> указывает, имеет ли нажатие клавиши
звуковое сопровождение; значения поля задаются в %; 0 -
звукового сопровождения нет, 100 - громкий звук. Поле
<code>bell_percent</code>,
<code>bell_pitch</code> и
<code>bell_duration</code> указывают, какую силу, частоту и
продолжительность имеет предупреждающий сигнал, возникающий при нажатии
некоторых клавиш.

<br>
<br>

Некоторые клавиатуры используют для клавиш-модификаторов световую подсветку.
Поле <code>led_mask</code> представляет собой комбинацию флагов,
показывающую, для каких клавиш эта подсветка используется.

<br>
<br>

Когда клавиша нажата и удерживается, то сервер может автоматически
имитировать ее повторное нажатие. Поле
<code>global_auto_repeat</code> определяет, делает это сервер или нет.
Особенностью X является то, что автоматическую генерацию событий
о нажатии можно разрешать или запрещать для отдельных клавиш. Массив
<code>auto_repeats</code> содержит информацию о том, для каких клавиш
автоповтор включен, а для каких нет. Каждый бит массива соответствует
клавише с определенным физическим кодом. Если бит установлен,
то генерация разрешена, если сброшен, то запрещена. Каждый байт
<code>N</code> массива содержит биты для клавиш с кодами от
<code>8N</code> до <code>8N+7</code>.

<br>
<br>

Изменить параметры клавиатуры можно с помощью
<code>XChangeKeyboardControl()</code>.

<br>
<br>

Желаемые установки передаются через переменную, которая указывает
на структуру типа
<code>TXKeyboardControl</code>, определяемую следующим образом:

<pre>
TXKeyboardControl = record
     key_click_percent : longint;
     bell_percent : longint;
     bell_pitch : longint;
     bell_duration : longint;
     led : longint;
     led_mode : longint;
     key : longint;
     auto_repeat_mode : longint;
  end;
PXKeyboardControl = ^TXKeyboardControl;
</pre>

Первые четыре поля совпадают с аналогичными полями структуры
<code>TXKeyboardState</code>.
Поля <code>led</code> и <code>led_mode</code> позволяют сообщить серверу,
какие из клавиш-модификаторов должны сопровождаться подсветкой.
Если поле <code>led</code> не задано, и <code>led_mode</code> равно
<code>LedModeOn</code>, то изменяется состояние всех клавиш,
для которых поддерживается световое сопровождение.
Если <code>led_mode</code> равно <code>LedModeOff</code>,
то состояние клавиш не меняется. Если поле <code>led</code> задано,
то это есть комбинация флагов, указывающих, для каких клавиш
подсветку включить (<code>led_mode</code> равно <code>LedModeOn</code>)
или выключить (<code>led</code>_mode равно <code>LedModeOff</code>).

<br>
<br>

Поля <code>key</code> и <code>auto_repeat_mode</code> определяют,
для какой клавиши (клавиш) включить (<code>auto_repeat_mode</code>
равно <code>AutoRepeatModeOn</code>) или выключить
(<code>auto_repeat_mode</code> равно <code>AutoRepeatModeOff</code>)
режим автоматического повтора. Если поле <code>key</code> задано,
то автоматический повтор включается или выключается только для клавиши
с кодом <code>key</code>.

</dir>
<br>


<!-- end of CONTENT -->
<!--#include virtual="/t_footer.htm"-->
